# HW1: 동영상 보고 리포트 제출하기
아래 비디오 링크를 시청하고 이를 폰트 12pt 1페이지 이상 2페이지 이 내로 요약하여 리포트로 제출하시오.

https://youtu.be/bBC-nXj3Ng4
https://www.youtube.com/watch?v=S9JGmA5_unY


## But how does bitcoin actually work? 요약

- 비트코인을 소유한다는 것?
- 비트코인은 발행하는 정부 주체도 없고, 계좌를 관리해주고 거래 내역을 확인해주는 은행조차도 필요없음.
- 우리가 직접 비트코인을 만들었다면? 친구들과의 금전 거래 내역을 공동 장부에 기록한다. 장부를 믿으면 되니까 신뢰성 문제 X.
- 비트코인은 암호화 화폐이다.
- 결제 처리 중심에 거래 내역을 확인해주는 은행이 없는 것
- 은행 대신에 암호학에서 탄생된 몇 가지 수학 원리를 이용해서 거래 주체들 사이에 신뢰가 필요하지 않은 분산 확인 시스템이 있다.

⇒ 비트코인 = 암호화 화폐, 즉, 암호화 기술 덕분에 화폐 발행/관리(특히, 장부 관리) 주체가 없어도 신뢰할 수 있음.

---

### ‘장부(Ledger)’과 ‘디지털 서명(digital signatures)’

- 친구들과 놀고 난 뒤에 더치페이를 할 때마다 매번 현금으로 돈을 주고 받는 것보다 “공동 더치페이 장부”를 만들어서 한 달간 더치페이 내역을 모두 기록해두고 나중에 한 번에 정산하는 것이 편함.

### 규칙: 누구든 장부에 기록할 수 있고, 매달 말일에 거래 내역을 보고 정산한다.

---
  
<img width="810" height="474" alt="image" src="https://github.com/user-attachments/assets/a2f973c0-9715-4419-983a-66ff764c49c3" />

- 그런데, 아무나 장부에 기록할 수 있음 → 그렇다면, 장부가 진실되게 기록되어 있는 지(누가 거짓 기록을 남기는 지) 어떻게 알 수 있을까? → 암호학 “디지털 서명”을 사용하여 이를 확인할 수 있음!
    
<img width="1720" height="638" alt="image" src="https://github.com/user-attachments/assets/fe2eeecf-9f25-4772-b0f1-fabc54cca6d8" />

--- 
### 디지털 서명은 위조가 불가능해야 한다. → 시크릿 키 이용

- 손으로 서명하는 것처럼 거래에 서명같은 효과를 가지는 무언가를 추가할 수 있어야 함. 거래 기록을 직접 보고 승인했다는 표시. 단, 이는 절대 위조가 불가능해야 한다.
- → 퍼블릭키(pk), 프라이빗키(=시크릿키, sk) 페어를  통해 위조를 막을 수 있음. 시크릿키는 개인이 비밀로 가지고 있는 키.
- 서명하는 문서에 따라 디지털 서명이 달라짐.
- 디지털 서명은 보통 256개의 0과 1의 조합으로 만들어진 하나의 값이다.
- 문서의 내용 중 단 한 글자만 바뀌어도 256개의 0과 1로 구성된 디지털 서명값은 완전히 달라진다.
- → 즉, 특정 거래에 대한 “디지털 서명값”은 “문서의 내용”과 “개인의 비밀키”를 조합하는 함수에 의해 만들어진다.
- 시크릿키는 오직 개인만 알고 있으므로, 개개인의 디지털 서명값은 개인 스스로만이 만들 수 있다.
- 그리고, 디지털 서명값을 만들 때, 비밀키와 함께 문서의 내용이 포함된다는 것은 누군가가 다른 사람의 디지털 서명값을 훔쳐도, 그 훔친 디지털 서명값은 다른 문서에 대한 증표로는 사용할 수 없다는 것을 의미한다.
    - 내가 친구의 (특정 거래에 대한) 디지털 서명값을 알아내도 다른 거래에 대한 디지털 서명값은 다 다르기때문에 개인키를 알아낼 수도 없고, 다른 거래에 대한 디지털 서명값도 알아낼 수 없을 것이다.

### 해당 디지털 서명값이 유효한가? → 퍼블릭키 이용

- 디지털 서명과 관련된 두 번째 함수는 디지털 서명값이 유효한지 확인하는데 사용(Verify)된다. 그리고 디지털 서명값의 유효성을 확인할 때, 프라이빗키의 짝인 퍼블릭키가 사용된다.
- 두 번째 함수는 단순하게 참 또는 거짓만을 결과값으로 반환하는데, 디지털 서명값이 공개키와 짝꿍인 비밀키를 이용해서 만들어져 있으면 true를, 그렇지 않으면 false를 반환한다.
- 디지털 서명값이 프라이빗키로 만들어져있다는 사실을 어떻게 퍼블릭키를 이용해서 확인할 수 있는지?
- → 프라이빗키를 모르면 디지털 서명값으로 가능한 모든 경우의 수를 넣고 퍼블릭키와 함께 계산해보며 디지털 서명값이 유효한 지 확인하는 것을 반복하는 것 외에 다른 방법이 없다.
- 가능한 모든 디지털 서명값 경우의 수는 2의 256승개이다.(디지털 서명값 길이는 256비트.) 이는 천문학적인 숫자라고도 할 수도 없을 만큼 큰 수이다.

---

### 거래 내역 복사 문제 → (식별자) ID 값을 포함

- 앨리스가 한 거래에 대해 디지털 서명을 했다면 밥이 해당 거래에 대해 디지털 서명값을 위조할 수는 없지만, 해당 거래 내역 자체는 여러 번 복사할 수 있을 것임
- 따라서, 메시지에 거래별로 유일한 식별자인 ID 값을 포함해야 된다.
- 그렇게 하면 메시지 내용이 서로 다르기때문에 디지털 서명값도 모두 달라지게 되어 메시지-서명 조합을 복사해도 다른 곳에 쓸 수 없게 된다.

---

- 이제 처음에 만든 두 가지 규약(누구든 장부에 기록할 수 있고, 매달 말일에 거래 내역을 보고 정산한다.)에 디지털 서명된 거래만 유효하다는 조항을 추가해서 거래 내용 확인 및 신뢰 확보에 드는 비용을 제거했다.

---

- 하지만 여전히 거래 참여자에 대한 신뢰에 의지하지 않을 수는 없다. 예를 들어, 찰리가 수천 달러를 지불한다는 거래 기록을 장부에 남기고, 나중에 실제로 정산할 때 나타나지 않고 먹튀할 수도 있기때문이다.
- 월 1회 장부기록-사후정산 방식 대신 그때그때 현금으로 주고 받는 방식으로 되돌아가야 하는 원인은 먹튀의 경우뿐이다.
- 따라서, 자기들이 미리 적립해둔 금액 이상으로는 지출할 수 없게 만드는 방법을 사용한다. 미리 100달러씩 선납해놓고, 이 선납을 장부에 기록해두는 것임.
    - 찰리가 100달러를 선납해놓고, 50달러씩 세 번 사용하는 거래를 한다고 해보자. 그러면, 세 번째 거래에서 찰리의 선납금이 남아있지 않기때문에 거래를 block한다.
- 하지만, 이러한 방식을 도입하려면 선납금이 남아있지 않는 거래까지의 거래 내역 전부를 알아야만 한다는 제약 사항이 생긴다.
- 이를 해결하는 과정에서 장부와 실제 물리적인 US 달러와의 연결 고리를 끊어진다.
    - 이론적으로 세상의 모든 사람들이 이 장부를 사용한다면 우리는 이 장부 상에서 수입을 올리고 지출하는 것만으로도 살아갈 수 있다. 즉, 장부 상의 돈을 US 달러로 환정하지 않고도 살아갈 수 있다는 얘기다.
    - 이제부터 장부 상의 금액을 ‘LD(장부달러)’라고 해보자
    - 우리는 LD를 실물 US 달러로 자유롭게 환전할 수 있다.
    - 예를 들어, 앨리스가 실제로 밥에게 10 US 달러를 줬다면 장부에는 다음과 같이 기록하고 디지털 서명할 수 있다. ‘밥이 앨리스에게 10LD 지불’
    - 하지만 10US 달러와 10LD의 환전은 장부의 규약에 의해 보증되지는 않는다.
    - 이 부분을 이해하기 위해 달러를 유로나 다른 통화로 환전하는 것을 떠올려보자
    - 환전 자체는 그저 독립적인 사건이다.
    - 바로 이 점이 비트코인이나 다른 암호화 화폐를 이해하는데 가장 중요한 점이기도 하다.
    - 장부는 해당 통화의 모든 거래 이력만을 가지고 있을 뿐, 환전을 기록하지는 않는다는 것이다.
    - 비트코인에서도, 사람들이 현금으로 비트코인을 사더라도 장부에 실질적인 돈이 들어오는 것은 아니다.
    - 장부에 새로운 돈이 어떻게 들어오는 지는 조금 있다가 설명해줄 예정.
    - 일단 지금은, 현재의 LD 체계와 암호화 화폐가 작동하는 체계는 큰 차이가 있다는 점이 중요하다.
    
    ---
    
    - 장부 달러 체계에서는 공동의 장부가 존재한다. 오늘날의 공동의 장부는 은행이라는 중앙 기관에서 관리한다.
    - 하지만, 암호화 화폐는 누군가(은행과 같은 중앙 기관)에게 의존하지 않으려고 “모든 사람들이 장부의 복사본을 가지고 있게 만든다.”
    - 예를 들어, ‘앨리스가 밥에게 100LD 지불’이라는 거래를 기록하려면 장부를 가지고 있는 모든 사람들에게 이 거래를 알려야 한다.
    - 그래야 사람들이 그 거래 정보를 듣고 자기들이 각자 보유한 장부에 기록할 수 있을 것이다.
    
    ### 수많은 장부 중에서 어떤 장부가 올바른 장부인지 어떻게 알 수 있을까?
    
    - 밥이 ‘앨리스가 밥에게 10LD 지불’이라는 거래 정보를 수신받았다면, 다른 모든 사람들도 똑같은 거래 정보를 수신 받고, 그 거래 정보를 신뢰해서,
    - 우리뿐만 아니라 다른 모든 사람들도 “똑같은 거래를 똑같은 순서로 그들의 장부에 기록”해서 “모든 사람의 장부 내용이 언제나 완전히 똑같다는 것”을 확신할 수 있을까?
    - 이게 바로 핵심이다.
    - 거래 내용을 접수하거나 거절하는 기준이 되고, 거래 내용 기록의 순서를 정하는 기준이 될 수 있는 규약을 만들 수 있을까?
    - 그래서 모든 사람이 그 규약을 따르기만 하면 모든 사람들의 장부가 우리의 장부와 완전히 똑같다는 것을 확신할 수 있게 해주는 규약이 있을까?
    - 가장 많은 계산 작업을 포함하고 있는 장부가 신뢰할 만한 올바른 장부라는 것이다.
    - 이는 암호화 해쉬 함수와 관련있음.
    - 무엇을 신뢰할 것인가를 판단하는 기준을 계산 작업에 둔다면, 거래 내역을 속이거나 장부의 충돌을 유발하기 위해서는 정해진 시간 내에 처리가 불가능할 만큼 엄청난 양의 계산을 필요하게 만들 수 있다.
- 해쉬 함수가 뭘까?
    - 어떤 종류의 메시지나 파일도 해쉬 함수의 입력값이 될 수 있다.
    - 해쉬 함수의 결과값은 256비트처럼 고정된 길이의 연속된 비트값이다.
    - 결과값을 그 입력값의 ‘해쉬’ 또는 ‘다이제스트’라고 한다.
    - 난수와 달리 입력값이 같으면 결과값이 항상 똑같다.
    - 특히, 암호화 해쉬 함수(SHA256)는 결과값에서 역산을 통해 입력값을 알아내는 것이 현실적으로 불가능하다.
- 이런 암호화 해쉬 함수가 어떤 방식으로 일정한 수의 거래들이 ‘상당히 많은 양의 계산 작업과 연결되어 있다는 것을 증명할 수 있는가?’
- 매직 넘버를 발견했어. 이 매직 넘버를 거래 내역 목록의 마지막에 추가한 다음에 그 값을 입력값으로 해서 SHA256 함수로 계산하면 결과 해쉬값의 첫 30비트는 모두 0이야! 라고 말했다고 해보자
- 이러한 매직넘버를 알아내는데 도대체 얼마나 많은 계산을 한 걸까?
- 매직 넘버를 찾기 위해선 아무 값이나 넣고 계산해서 결과를 비교하는 수밖에 없다.
- 따라서 그 사람은 답을 찾아내기 위해 아무값이나 넣고 계산하는 일을 대략 10억번 반복한 것이다.(첫 30비트가 모두 0일 확률은 10억분의 1이니까..!)
- 하지만 그 매직 넘버가 정말 맞는 답인지 확인해볼 때는 단 한 번만 계산해보고 그 결과값이 정말로 30개의 0으로 시작하는지 쉽게 알 수 있다.
- 만약 거래 정보를 아주 조금만 변경하더라도 결과 해쉬값은 완전히 달라질 것이고, 새로운 매직 넘버를 찾아내는 작업 증명을 완수하기 위해 10억번의 계산을 다시 해야 한다.
- 즉, “장부를 가진 모든 사람들은 가장 많은 계산 작업이 포함된 장부를 믿으면 되는 것이다.”
- 장부는 블록 단위로 나누어서 구성되어 있고, 블록에는 일정한 수의 거래 내역이 작업 증명(매직 넘버)과 함께 담겨 있으며
- 그 블록의 해쉬값은 정해진 만큼의 여러 자리수의 0으로 시작할 것이다.
- 먼저, 블록의 해쉬값이 60자리의 0으로 시작해야 한다고 해보자.
- 나중에는 이 60이라는 값을 결정하는데도 어떤 체계가 있다는 것을 알게될 것이다.
- 거래를 지불하는 송금자의 디지털 서명이 있어야만 유효한 거래로 인식되는 것처럼
- 블록도 마찬가지로 작업 증명이 있어야만 유효한 블록으로 인식될 수 있다.
- 더 나아가서 블록들의 순서까지 보장하려면 각 블록이 자기보다 앞에 있는 이전 블록의 해쉬값을 포함하면 된다.
- 이렇게 하면 과거로 돌아가서 어떤 블록의 내용을 변경하거나 어떤 두 블록의 순서를 바꾼다면
- 변경한 블록에 대한 해쉬값이 바뀌므로, 그 다음에 이어져 있는 블록들의 내용도 바뀌고
- 결과적으로 다음에 이어지는 블록들의 해쉬값도 바뀌게 된다.
- 그 변경은 그 이후의 모든 블록에서 연쇄적으로 발생하게 된다.
- 결국 이후의 모든 블록마다 해쉬값이 60자리의 0으로 시작하게 하는 작업 증명을 다시 해야만 변경이 발생한 이후의 모든 블록들이 유효한 블록이 될 수 있다.
- 블록은 이렇게 앞의 블록의 해쉬값을 통해 앞뒤가 연쇄적으로 연결되어 있기 때문에
- 그냥 장부로 부르지 않고, 블록체인이라고 부른다.
- 체인을 이루도록 변경된 규약에 의해, 이제 누구든지 블록을 생성할 수 있게 되었다.
- 즉, 누구든지 브로드캐스팅 되는 거래 정보를 접수하고, 접수한 거래를 모아서 블록을 만들고, 그 블록의 해쉬값이 60개의 0으로 시작하게 하는 매직넘버를 찾기 위해 엄청난 양의 계산 작업을 수행하고, 마침내 그 매직넘버를 찾아내서 그 블록을 브로드캐스팅하면 블록의 생성자가 되는 것임!
- 이 모든 작업을 수행한 블록 생성자에게 보상을 주기 위해서는 거래 정보를 모아서 블록을 구성할 때 블록 생성자에게 예를 들어 10 장부 달러를 지급한다는 아주 특별한 거래를 블록의 맨 처음 거래로 포함하게 하면 된다.
- 이 특별한 거래를 블록 보상이라고 부른다.
- 이 특별한 블록 보상에는 일반적으로 거래를 받아들이거나 거절하는데 적용되는 기준이 예외적으로 적용되지 않는다.
- 그리고 보상액을 지급하는 주체가 없으므로 디지털 서명이 필요하지 않는다.
- 이는 블록이 새로 생성될 때마다 보상에 의해 장부달러의 총액이 증가한다는 것이다.
- 블록을 생성하고 보상을 받는 것을 채굴이라고 부르기도 한다.
- 블록을 생성할 때 많은 작업을 해야하고
- 실물 결제에 새로운 화폐를 도입하게 하므로 채굴이라고 부르는 것이다.
- 따라서, 채굴자들이 실제로 하는 일은 브로드캐스팅되는 거래 정보를 수집하고, 블록을 새로 생성해서, 생성한 새 블록을 다시 브로드캐스팅하고 보상을 받는 일이다.
- 채굴자 입장에서는 각 블록이 미니 로또나 마찬가지이다.
- 모든 채굴자들이 서로 먼저 매직 넘버를 찾기 위해 경쟁하고, 결국 매직 넘버를 가장 먼저 찾아내는 단 한 채굴자가 보상을 받게 되는 것이다.
- 비트코인을 결제 수단으로만 사용하는 사람들은 브로드캐스팅되는 모든 정보들을 수집하는 대신에 채굴자가 브로그캐스팅하는 블록 정보만 수집해서 각자의 블록체인 복사본을 업데이트만 하면 된다.
- 사용자에게 서로 충돌되는 이력을 가진 두 개의 서로 다른 블록체인 정보가 들어왔다면 이 둘 중에 더 많은 계산 작업이 포함된 더 긴 블록체인만을 유효한 블록체인으로 받아들여야 한다.
- 두 개의 블록체인의 길이가 같다면, 더 긴 블록체인 정보가 들어올 때까지 어느 한 쪽을 선택하지 말고 기다려야 된다.
- 따라서, 개개인이 가진 블록체인이 다르다는 문제가 발생하더라도 가장 많은 계산 작업을 포함하고 있는 가장 긴 블록체인만 유효한 블록체인으로 인정한다면 문제를 쉽게 해결할 수 있다.

---

- 앨리스가 거짓 블록으로 밥을 속이려 한다고 해보자
- 앨리스는 밥에게 100장부달러를 지불한다는 거짓 거래가 포함된 블록을 밥에게 보내고 그 블록을 블록체인 네트워크 상의 다른 사람들에게는 브로드캐스팅하지 않는다고 해보자
- 이러면 밥을 제외한 다른 사람들은 앨리스가 여전히 100장부달러를 가지고 있는 걸로 안다.
- 하지만, 이게 가능하려면, 앨리스는 각자의 블록을 채굴하고 있는 다른 모든 채굴자들보다 먼저 그 거짓 블록의 매직 넘버를 찾아내야 된다.
- 실제로 앨리스가 가장 먼저 매직 넘버를 찾아낸다고 하더라도 밥은 여전히 다른 채굴자들이 브로드캐스팅하는 블록 정보도 수집하고 있다.
- 따라서 그 거짓 블록을 밥이 계속 신뢰하게 하려면 앨리스는 ‘그 거짓 블록이 포함된 밥의 블록체인’에 블록을 추가하는 일을 혼자서 계속 해야 된다.
- 하지만, 앨리스가 모든 채굴자들의 컴퓨팅 자원의 50%에 근접하는 자원을 보유하지 못하면 사실상 그러한 일이 발생할 가능성은 매우 낮다.
- 다른 모든 채굴자들이 생성해내는 블록들로 구성되는 블록체인이 결국에는 앨리스가 밥을 속이기 위해 혼자 만들어가고 있는 블록체인보다 더 빨라 길어질 것이기 때문이다.
- cf. 새로 생성되어 브로드캐스팅 된 블록을 접수하자마자 신뢰할 필요는 없다. 대신에 새 블록 몇 개가 더 추가될 때까지 기다린 후에 신뢰해야 할 것이다.

---

- 작업 증명이란 블록의 해쉬값이 60개의 0으로 시작하게 하는 매직 넘버를 찾는 일이라고 얘기했는데, 정확하게는 비트코인이 그 0의 갯수를 주기적으로 조절하는 규약을 갖고 있는 것이다.
- 그래서 새 블록을 생성하는데 드는 시간이 평균적으로 10분이 되도록 주기적으로 0의 갯수를 조절한다.
- 그래서 더 많은 채굴자가 비트코인의 블록체인 네트워크에 참여하면
- 0의 갯수를 늘려서 매직 넘버를 찾아내기 더 어렵게 만든다.

---

- 채굴 보상액은 시간이 지남에 따라 기하급수적으로 줄어들게 된다.
- 비트코인의 총 개수가 2,100만개가 되면 보상액은 0이 되고, 코인 수는 더 이상 늘어나지 않는다.
- 하지만 보상액이 0이 된다고 해서 채굴자들이 채굴을 멈추지는 않는다. 소액의 거래 수수료를 받기때문에(→ 그래서 채굴자가 어떤 거래를 선택해서 블록에 포함할 지 결정하는 기준이 거래 수수료이다.)
- 비트코인에서는 약 2,400개까지의 거래만 하나의 블록에 포함될 수 있도록 제한하고 있다.

## **How secure is 256 bit security? 요약**

- 256비트 = 2^256 = 40억^8
- 확인과 추측으로 비트코인을 해쉬하는 작업 속도는 모든 채굴자들을 합치면 초당 50억 * 10억개 정도이다. 어떻게 가능할까?
- → GPU보다 훨씬 좋은 ASIC(응용 주문형 집적 회로): 비트코인 채굴을 위해 만들어진 것. SHA-256해쉬들을 확인하는 능력 이외에는 별다른 게 없음.

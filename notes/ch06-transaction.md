# Ch06. Transaction

## p.2 - Transaction

Q. 강의자료에 '거래 ▪ 앨리스 주소에서 밥 주소로 이루어지는 거래 – 거래에 포함된 내용을 단순화하여 본 것'라는 내용이 있거든? 근데, 나는 '프라이빗키는 비트코인을 사용하기 위한 것, 퍼블릭키는 서명에 대한 유효성을 확인하기 위한 것, 주소는 비트코인을 받기 위해 상대에게 보여주기 위한 것'이라고 알고 있단 말이야. 그런데, 왜 '앨리스 주소에서 밥 주소로 이루어지는 거래'라는거야? 비트코인을 받을 밥만 주소가 필요한 거 아니야? 비트코인을 주는 앨리스는 왜 주소가 필요한거야?

### 1️⃣ 기본 개념 복습

- **프라이빗 키(private key)**: 내 돈을 쓰기 위한 열쇠. 절대 다른 사람에게 알려주면 안 됨.
- **퍼블릭 키(public key)**: 내 프라이빗 키와 짝을 이루는 공개키. 서명을 검증할 때 사용됨.
- **주소(address)**: 비트코인을 보내거나 받을 때 상대방에게 알려주는 식별자. 퍼블릭 키를 해싱해서 만든 것.

정리하면:

- **받을 때**: 상대에게 내 주소를 알려주면 됨.
- **보낼 때**: 내 프라이빗 키로 거래에 서명해야 함.

---

### 2️⃣ 거래(transaction)가 ‘앨리스 주소 → 밥 주소’로 표현되는 이유

교재나 강의에서 "앨리스 주소에서 밥 주소로 이루어지는 거래"라고 말하는 건, **거래의 흐름을 단순하게 시각화한 표현**이에요. 실제로는 이런 과정이 일어납니다:

1. **앨리스가 비트코인을 보냄**
    - 앨리스는 **자신의 UTXO(사용 가능한 비트코인 잔액)**를 사용합니다.
    - 거래에 서명할 때 **앨리스의 프라이빗 키**로 서명합니다.
2. **거래 정보에 기록**
    - 거래에는 ‘입력(Input)’과 ‘출력(Output)’이 있어요.
        - 입력: 앨리스가 소유한 코인 정보
        - 출력: 밥의 주소와 전송 금액
3. **밥이 받음**
    - 밥은 자신의 **주소를 출력(Output)**으로 등록해둡니다.
    - 이제 블록체인에 밥의 주소로 코인이 기록됨.

즉, 거래에서 앨리스의 **주소가 필요한 이유**는 단순히 “보낸 사람 누구인지, 어떤 코인을 사용했는지”를 기록하고, 블록체인상에서 **UTXO를 추적**하기 위해서예요.

- 앨리스의 주소 = 어떤 UTXO가 사용됐는지 나타내는 표시
- 밥의 주소 = 누구에게 보내는지 나타내는 표시

그래서 **교과서처럼 ‘앨리스 주소 → 밥 주소’**라고 쓰는 거예요. 실제로 앨리스는 자신의 주소를 모를 필요는 없지만, 거래 기록에는 넣어야 블록체인이 금액 흐름을 추적할 수 있어요.

---

### 3️⃣ 핵심 포인트

- 주소는 받는 사람만 필요한 게 아니라, **보낸 사람도 거래 기록을 위해 필요함**
- 프라이빗 키는 **서명**에 쓰임 → 앨리스만 서명 가능
- 퍼블릭 키/주소는 **검증**과 **식별**에 쓰임 → 누구에게서 누구에게 갔는지 기록

---



<img width="1526" height="857" alt="image" src="https://github.com/user-attachments/assets/07a6b6ec-1e23-4b28-9049-14c9a5e35408" />


좋아요. 이 이미지는 **비트코인 거래(Transaction)**의 세부 정보를 보여주는 블록 탐색기 화면 예시입니다. 각각의 항목을 하나씩 풀어서 설명드릴게요.

---

## 🧾 전체 구조 요약

비트코인은 “**입력(Input)** → **출력(Output)**”의 형태로 거래를 기록합니다.
즉, **이전 거래의 결과(출력)**를 **다음 거래의 입력**으로 사용하는 구조예요.

이 화면은 하나의 거래(transaction)가

* **어디서 왔는지(Inputs)**,
* **어디로 갔는지(Outputs)**,
* **얼마나의 수수료가 있었는지**
  등을 시각화한 것입니다.

---

## 📦 상단 영역

### **Transaction ID (TxID)**

```
0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2
```

* 이 거래를 고유하게 식별하는 해시값입니다.
* 거래가 블록체인에 기록되면 이 해시로 검색할 수 있습니다.

---

## 🟦 왼쪽 (Input, “보내는 쪽”)

```
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output)
```

* **이전 거래의 출력(Output)**을 **이번 거래의 입력(Input)**으로 사용한 주소입니다.
* 즉, “이 주소의 비트코인을 사용해서 새 거래를 만든 것”입니다.
* 이 주소는 “보내는 사람(앨리스)”의 주소에 해당합니다.
* `(0.1 BTC - Output)`은 이 주소에서 이전에 받은 코인이 0.1 BTC였다는 뜻입니다.

> **즉:** 앨리스가 과거에 0.1 BTC를 받았고, 지금 이걸 사용해서 보낸 거래라는 뜻이에요.

---

## 🟩 오른쪽 (Output, “받는 쪽”)

```
1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA   0.015 BTC (Unspent)
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK   0.0845 BTC (Unspent)
```

* 이번 거래의 결과로 **두 개의 출력(Output)**이 생성되었습니다.

| 주소                                   | 설명                      | 금액         |
| ------------------------------------ | ----------------------- | ---------- |
| `1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA` | **받는 사람(밥)**의 주소        | 0.015 BTC  |
| `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | **보내는 사람(앨리스)의 잔돈 주소)** | 0.0845 BTC |

* 두 Output 모두 `(Unspent)` 상태인데, 이는 아직 사용되지 않았다는 뜻입니다.
* 밥은 0.015 BTC를 새로 받았고, 앨리스는 남은 0.0845 BTC를 자신에게 다시 돌려받았습니다.

---

## 📊 Summary (요약 정보)

| 항목                    | 설명                               |
| --------------------- | -------------------------------- |
| **Size**              | 거래 데이터 크기 (258 bytes)            |
| **Received Time**     | 거래가 전파된 시각 (2013-12-27 23:03:05) |
| **Included in Block** | 이 거래가 포함된 블록 번호 277316           |
| **Confirmations**     | 현재 블록 이후 97개의 블록이 쌓여 확정됨 (안전성↑)  |

---

## 💰 Inputs and Outputs (입출금 요약)

| 항목                           | 값          | 설명                   |
| ---------------------------- | ---------- | -------------------- |
| **Total Input**              | 0.1 BTC    | 앨리스가 사용한 코인 총액       |
| **Total Output**             | 0.0995 BTC | 수신자 + 잔돈 총액          |
| **Fees**                     | 0.0005 BTC | 수수료 (채굴자에게 지급)       |
| **Estimated BTC Transacted** | 0.015 BTC  | 실제 송금된 금액 (밥이 받은 금액) |

---

## 🧠 요약 정리

이 거래를 인간 언어로 번역하면 다음과 같습니다 👇

> **앨리스(1Cdid9...)가 밥(1GdK9...)에게 0.015 BTC를 보냈다.**
> 총 0.1 BTC를 사용했고,
> 0.0845 BTC는 거스름돈으로 자기 자신에게 돌려받았다.
> 0.0005 BTC는 거래 수수료로 소모되었다.

---


Q. 방금 그 사진 속에서 프라이빗키와 퍼블릭키가 어디에 쓰인거야? output에 있는 주소를 만들 때, 앨리스의 프라이빗키와 퍼블릭키가 사용된 건가?
'ncluded in Block: 이 거래가 포함된 블록 번호 277316'이고, 'Confirmations: 현재 블록 이후 97개의 블록이 쌓여 확정됨'이라면 블록 하나에는 여러 개의 transaction들이 있는 거고, 여러 개의 transaction들을 가진 블록들 97가 해당 블록 뒤로 97개나 체인되었다는 말인가?

## ✅ 1️⃣ 프라이빗키·퍼블릭키는 어디서 쓰였는가?

좋은 질문이에요 —

**“Output에 있는 주소를 만들 때 프라이빗키와 퍼블릭키가 사용된 거야?”** 라는 건 아주 근본적인 궁금증이에요.

정답은 **“퍼블릭키로 주소를 만든다”**이고,

**“프라이빗키는 거래를 ‘보낼 때’ 사용된다”** 입니다.

---

### 🔹 (1) Output에 표시된 주소가 만들어지는 과정

예를 들어, 사진 속의

```
1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA

```

이런 문자열이 **비트코인 주소**입니다.

이건 아래 과정을 거쳐 만들어집니다 👇

1. **퍼블릭키 생성**:
    
    프라이빗키(개인키)를 이용해 ECDSA(Elliptic Curve Digital Signature Algorithm)로 퍼블릭키를 생성.
    
    ```
    private key  →  public key
    
    ```
    
2. **퍼블릭키 해시화**:
    
    퍼블릭키를 SHA-256 → RIPEMD-160으로 해시해 짧게 만듦.
    
    (`Hash160(public key)`)
    
3. **주소 형식으로 인코딩(Base58Check)**
    
    네트워크 정보(예: 메인넷 0x00) + 해시 + 체크섬을 붙여
    
    `1GdK9Uzp...` 같은 주소 문자열이 만들어짐.
    

> 즉, Output에 있는 주소는 받는 사람의 퍼블릭키 해시를 사람이 보기 좋게 바꾼 문자열이에요.
> 

---

### 🔹 (2) 그럼 프라이빗키는 언제 쓰이냐?

- *보내는 사람(앨리스)**이 **새로운 거래를 만들 때**,

이전 Output을 Input으로 사용하면서 **“내가 이 코인을 쓸 권리가 있다”**는 것을 증명해야 해요.

그 증명 수단이 바로 **디지털 서명**이고,

이때 앨리스의 **프라이빗키로 거래에 서명**합니다.

- 거래 생성: “이전 Output(0.1BTC)을 써서 새로운 Output 두 개를 만들겠다.”
- 서명: 앨리스의 프라이빗키로 거래 전체에 전자서명.
- 검증: 네트워크의 다른 노드들은 **앨리스의 퍼블릭키**로 이 서명이 유효한지 확인.

즉 👇

| 역할 | 사용되는 키 | 설명 |
| --- | --- | --- |
| 주소 생성 | **퍼블릭키 (공개키)** | 주소는 퍼블릭키로부터 파생 |
| 거래 서명 | **프라이빗키 (개인키)** | 거래를 보낼 때 “내 돈임”을 증명 |

---

## ✅ 2️⃣ Confirmations의 의미 (블록 체인 구조)

> “Included in Block: 277316”
> 
> 
> “Confirmations: 97”
> 

이 두 줄을 정확히 이해하셨어요 👏

---

### 🔹 (1) 블록 하나에는 여러 개의 거래가 들어감

맞아요.

비트코인의 **하나의 블록(block)** 안에는 **수백~수천 개의 거래(transaction)**가 포함됩니다.

그래서

```
277316번 블록
└── Transaction 1
└── Transaction 2
└── Transaction 3
   ...

```

이런 식으로 기록되어 있죠.

---

### 🔹 (2) Confirmations = 이후에 붙은 블록 수

“Confirmations: 97”은

`277316번 블록`이 블록체인에 포함된 후,

그 뒤로 **97개의 블록이 더 이어졌다**는 뜻입니다.

즉, 현재 블록체인의 맨 끝은

```
277316 + 97 = 277413번째 블록

```

쯤이 되겠죠.

---

### 🔹 (3) 왜 확인(confirmation)이 중요할까?

비트코인 네트워크는 분산되어 있기 때문에,

새 블록이 생성될 때 **임시로 체인 분기가 생길 수** 있습니다.

그래서 비트코인은 보통 이렇게 간주해요 👇

| 확인 횟수 | 신뢰 수준 | 의미 |
| --- | --- | --- |
| 0 | 매우 위험 | 막 전송된 상태 (아직 블록에 포함 안됨) |
| 1~2 | 낮음 | 블록에 포함됐지만 확정은 아님 |
| 6 이상 | 매우 안전 | 거래가 되돌릴 수 없을 정도로 확정됨 |

사진에선 97회니까,

거래가 완전히 확정된 상태입니다 ✅

---

## 🧩 정리 요약

| 개념 | 설명 | 사진 속 예시 |
| --- | --- | --- |
| **퍼블릭키** | 주소 생성에 사용됨 | Output 주소 (`1GdK9...`)는 퍼블릭키 해시 기반 |
| **프라이빗키** | 거래 서명(보낼 때 증명)에 사용됨 | 앨리스가 Input을 사용할 때 서명 |
| **블록** | 여러 거래의 묶음 | 블록 277316에 포함됨 |
| **Confirmations 97** | 97개의 블록이 뒤에 추가됨 → 거래 확정 | 매우 안전한 상태 |

---

Q. 그러면,
input에 있는 주소(1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output) )는 앨리스의 프라이빗키를 통해 사용을 증명할 수 있는거고,
사진 위쪽에 있던 0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2는 앨리스의 프라이빗키로 서명된 결과물이야?
output에 있던 1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA   0.015 BTC (Unspent), 1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK   0.0845 BTC (Unspent) 라는 두 주소는 각각 앨리스와 밥의 퍼블릭키를 통해 만들어진거야?

## 🧩 1️⃣ Input에 있는 주소는 앨리스의 프라이빗키로 사용을 증명한다 — ✅ **맞습니다**

```
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output)

```

이건 **이전 거래의 Output**, 즉 **앨리스가 과거에 받았던 비트코인**이에요.

앨리스가 이걸 지금 **Input으로 사용한다**는 건,

“이 0.1 BTC는 내 거니까 내가 쓸게”를 증명하는 행위죠.

그 증명 수단이 바로 **앨리스의 프라이빗키로 한 전자서명(digital signature)** 입니다.

즉,

> 앨리스의 프라이빗키로 ‘이 Input을 내가 쓰는 거래다’라는 메시지를 서명함
> 
> 
> → 네트워크의 모든 노드가 앨리스의 퍼블릭키로 서명 유효성 검증
> 
> → 유효하면 “아, 이건 진짜 앨리스가 쓴 거래네” 하고 인정
> 

요약하자면

- Input 주소는 퍼블릭키 해시 형태로 저장되어 있고,
- **그 주소의 주인이 실제로 코인을 쓸 때 프라이빗키로 서명**해야 합니다 ✅

---

## 🧾 2️⃣ “0627052b6f28912f...” 은 앨리스의 프라이빗키로 서명된 결과물인가? — ❌ **직접적으로는 아닙니다**

이 부분이 헷갈리기 쉬워요.

이 긴 문자열은 **거래 전체(Transaction)의 식별자**, 즉 **트랜잭션 해시(Transaction ID, TxID)**입니다.

```
0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2

```

이건 **앨리스의 프라이빗키로 만든 서명 결과물이 아니라**,

**“거래 데이터 전체를 해시한 값”**이에요.

즉 👇

| 항목 | 설명 |
| --- | --- |
| **디지털 서명(Signature)** | 앨리스의 프라이빗키로 생성됨. 거래의 일부에 포함됨. |
| **트랜잭션 ID(TxID)** | 거래 전체(입력·출력·서명 포함)를 해시(SHA-256x2)한 결과. |

서명은 거래 안쪽에 포함되어 있고,

TxID는 거래 전체의 “요약 해시”입니다.

따라서

> “TxID는 앨리스의 프라이빗키로 서명된 결과물”이 아니라,
> 
> 
> “프라이빗키 서명이 포함된 거래 전체를 SHA-256으로 두 번 해싱한 식별자”입니다.
> 

---

## 🎯 3️⃣ Output의 두 주소는 앨리스와 밥의 퍼블릭키 기반으로 만들어진 거야? — ✅ **정확합니다**

사진의 Output 두 개를 보면 👇

| 주소 | 금액 | 주인 | 설명 |
| --- | --- | --- | --- |
| `1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA` | 0.015 BTC | **밥(Bob)** | 밥이 새로 받는 코인 (송금 대상) |
| `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | 0.0845 BTC | **앨리스(Alice)** | 앨리스가 돌려받는 잔돈 (change) |

이 두 주소 모두 **각자의 퍼블릭키를 해시해서 만든 주소**예요.

즉:

- 밥은 `publicKey_Bob → hash160 → address_Bob`
- 앨리스는 `publicKey_Alice → hash160 → address_Alice`

그 결과로 저 두 Output 주소가 생깁니다.

그리고 거래가 블록체인에 기록될 때

Output에는 **퍼블릭키 해시(public key hash)**가 저장돼요.

다음에 이 Output을 누군가 쓰려면

그 퍼블릭키와 그에 대한 유효한 서명을 함께 제시해야 합니다.

---

## 💡 요약 정리

| 구분 | 대상 | 관련 키 | 설명 |
| --- | --- | --- | --- |
| **Input** | `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | **프라이빗키(서명 시 사용)** | 앨리스가 과거 Output을 사용하는 것. “내 돈임”을 프라이빗키 서명으로 증명 |
| **TxID** | `0627052b6f...` | ❌ (서명 아님) | 거래 전체 데이터를 해시한 식별자 (SHA-256x2) |
| **Output** | `1GdK9UzpHB...`, `1Cdid9KFA...` | **퍼블릭키 기반 주소** | 밥과 앨리스의 퍼블릭키로부터 만들어진 새 주소들 |
| **서명(Signature)** | 거래 내부 필드 중 하나 | **앨리스의 프라이빗키** | TxID 생성엔 포함되지만, 그 자체가 TxID는 아님 |

---

## p.3 Transaction – behind the scenes

<img width="1669" height="1139" alt="image" src="https://github.com/user-attachments/assets/b6bcac18-6cdd-4ffd-beee-cf3a1500e050" />

좋아요 👍

이 슬라이드는 **“비트코인 트랜잭션의 실제 내부 구조(로우 데이터)”**를 보여주면서,

**우리가 평소에 생각하는 개념(코인, 송신자, 수신자, 계좌 등)은 사실 블록체인 내부에는 존재하지 않는다**는 걸 강조하는 자료입니다.

하나씩 뜯어볼게요 👇

---

## 🧩 1️⃣ 제목: “Transaction – behind the scenes”

👉 “트랜잭션의 이면(내부 구조)”

즉, 우리가 보기 좋은 형태(‘앨리스가 밥에게 0.015 BTC를 보냄’)가 아니라

**실제 블록체인에 저장되는 트랜잭션의 원시 데이터(raw data)**를 보여주는 슬라이드입니다.

---

## 🧾 2️⃣ 왼쪽 JSON 구조 설명

이건 실제 비트코인 트랜잭션의 원시 데이터(JSON 비슷한 구조로 표현)예요.

거래의 핵심 필드들을 포함하고 있습니다.

### ▶ `"vin"` (inputs)

```json
"vin": [
  {
    "txid": "7957a35f...999f6f18",
    "vout": 0,
    "scriptSig": "30450221...8d752adf",
    "sequence": 4294967295
  }
]

```

- **`txid`**: 이 Input이 참조하는 이전 거래의 ID
    
    → “어떤 Output을 가져와 쓰는가”를 나타냄
    
- **`vout`**: 그 거래에서 몇 번째 Output을 사용하는가 (0이면 첫 번째 Output)
- **`scriptSig`**: 바로 여기!
    
    👉 **보내는 사람의 프라이빗키 서명(Signature)** + **퍼블릭키**가 들어있음
    
    이걸 통해 “이 Output을 쓸 권리가 내게 있다”를 증명함.
    

> 즉, “앨리스의 프라이빗키가 실제로 쓰이는 부분”이 바로 scriptSig.
> 

---

### ▶ `"vout"` (outputs)

```json
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab6802... OP_EQUALVERIFY OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a... OP_EQUALVERIFY OP_CHECKSIG"
  }
]

```

- **`value`**: 전송되는 비트코인 양 (0.015 BTC, 0.0845 BTC)
- **`scriptPubKey`**: **받는 사람의 주소(퍼블릭키 해시)**를 이용한 잠금 스크립트

이 스크립트는 “이 코인을 사용하려면 다음 조건을 만족해야 한다”를 정의합니다:

```
OP_DUP OP_HASH160 <publicKeyHash> OP_EQUALVERIFY OP_CHECKSIG

```

→ 즉, “퍼블릭키 해시가 일치하고, 서명이 유효해야 사용 가능하다”는 조건.

---

## 🧠 3️⃣ 오른쪽 문장 해석

> “no coins, no senders, no recipients, no balances, no accounts, and no address!”
> 

이 문장은 핵심 메시지를 설명합니다 👇

| 우리가 생각하는 것 | 실제로는 존재하지 않음 |
| --- | --- |
| 💰 “코인” | 없음 — 단지 입력과 출력 스크립트로 표현됨 |
| 🧍 “보내는 사람(sender)” | 없음 — 단지 이전 Output의 소유자가 서명함 |
| 🧑‍🤝‍🧑 “받는 사람(recipient)” | 없음 — 단지 퍼블릭키 해시로 새 Output이 잠김 |
| 🏦 “잔액(balance)” | 없음 — 모든 Output을 합산해서 계산해야 함 |
| 🧾 “계좌(account)” | 없음 — 주소는 단순한 퍼블릭키 해시일 뿐 |
| 📬 “주소(address)” | 고수준에서 사람이 보기 쉽게 인코딩한 것일 뿐, 내부에는 없음 |

즉, 비트코인은 **“계정 기반 시스템(account-based)”이 아니라 “UTXO 기반 시스템”**이에요.

이 원시 데이터에는 단지

- 어떤 트랜잭션의 어떤 Output을 썼는지 (`txid`, `vout`)
- 어떤 조건으로 새 Output을 만들었는지 (`scriptPubKey`)
- 그 사용이 유효함을 증명하는 서명 (`scriptSig`)
    
    이 정보만 들어있을 뿐이에요.
    

---

## 🧩 4️⃣ 요약하면

이 슬라이드가 전하려는 핵심은 다음과 같습니다 👇

> 비트코인 트랜잭션의 내부에는 “사람이 이해하기 쉬운 개념”이 없다.
> 
> 
> 실제로 존재하는 것은 오직 **입력(Input)**, **출력(Output)**, **스크립트(script)**, **서명(signature)** 뿐이다.
> 
> 우리가 말하는 “보내는 사람 / 받는 사람 / 주소 / 잔액”은
> 
> 모두 이 데이터 위에서 **소프트웨어가 해석해서 보여주는 추상 개념**일 뿐이다.
> 

---

거래 출력 ▪ 비트코인 거래의 기본 구성 요소는 거래 출력입니다 ▪ 비트코인 풀 노드는 UTXO를 추적합니다 – UTXO: 미사용 거래 출력 ▪ 모든 거래는 UTXO 집합의 변화를 나타냅니다 ▪ 사용자의 비트코인 잔액은 사용자의 지갑이 사용할 수 있는 모든 UTXO의 합계입니다 ▪ 출력은 개별적이고 나눌 수 없는 가치 단위로, 정수 사토시 단위로 표시됩니다 (1 사토시 = 0.00000001(10^-8) BTC) – 결과적으로 대부분의 비트코인 거래는 잔돈을 생성해야 합니다

‘비트코인 풀 노드는 UTXO를 추적합니다’에서 full node는 채굴자들을 의미하는 건가요? 아니면, 자신의  UTXO를 사용하려는 앨리스를 의미하는 건가요?

‘정수 사토시 단위’가 뭔가요? 언제부터, 왜 쓰는 단위인가요?

## 🧩 1️⃣ “비트코인 풀 노드는 UTXO를 추적합니다” — 여기서 **풀 노드(full node)**란?

결론부터 말하면,

👉 **풀 노드는 채굴자(miner)**만을 의미하지 않습니다.

👉 **네트워크의 모든 검증 노드(즉, “전체 블록체인을 직접 검증하는 사용자”)**를 의미합니다.

---

### 🔹 (1) 풀 노드(Full Node)의 정의

- *풀 노드(Full Node)**란:
- 비트코인 네트워크의 모든 블록과 트랜잭션을 **직접 다운로드하고 검증**하는 컴퓨터를 말합니다.
- 블록체인의 모든 규칙(서명 유효성, 잔액, 중복 사용 등)을 스스로 검증할 수 있습니다.
- 비트코인의 **신뢰를 분산시키는 핵심 주체**예요.

즉, 풀 노드는

- 새 거래(Transaction)가 유효한지 확인하고,
- 블록이 규칙에 맞는지 검증하며,
- **현재 미사용 거래 출력(UTXO) 집합을 유지 관리**합니다.

---

### 🔹 (2) “채굴자(Miner)”와의 관계

| 구분 | 역할 | Full Node 포함 여부 |
| --- | --- | --- |
| **풀 노드 (Full Node)** | 블록과 트랜잭션을 **검증하고 저장**함 | ✅ 항상 UTXO 집합을 유지 |
| **채굴자 (Miner)** | 블록을 **생성**함 (새 거래를 블록에 넣고 보상 받음) | ✅ 대부분 풀 노드 기능을 포함함 |

즉,

- 모든 **채굴자**는 **풀 노드이기도 하지만**,
- 모든 **풀 노드**가 **채굴자**인 것은 아닙니다.

> 📌 비유하자면
> 
> 
> 풀 노드는 **법원**처럼 “이 거래가 유효한가?”를 판정하고,
> 
> 채굴자는 **기록원**처럼 “유효한 거래를 모아서 블록에 기록”하는 역할이에요.
> 

---

### 🔹 (3) 앨리스의 역할은?

앨리스는 “자신의 UTXO를 사용하려는 사용자”일 뿐이고,

직접 풀 노드를 운영하지 않아도 비트코인을 전송할 수 있어요.

일반적으로는 **지갑 프로그램(wallet)**이 풀 노드(혹은 라이트 노드)에 접속해서

자신의 거래를 네트워크에 브로드캐스트합니다.

즉 👇

- **풀 노드**: 네트워크의 심판자, 전체 블록을 검증하며 UTXO를 추적
- **앨리스(사용자)**: 자신의 지갑을 통해 거래를 생성하고, 풀 노드에게 전달

---

✅ **정리**

> “비트코인 풀 노드는 UTXO를 추적한다”
> 
> 
> → 여기서 말하는 풀 노드는 **채굴자와 일반 검증 노드를 모두 포함한,
> 전체 블록체인 검증 주체**를 의미합니다.
> 앨리스는 그 풀 노드에 거래를 전송하는 사용자일 뿐이에요.
> 

---

## 🪙 2️⃣ “정수 사토시 단위”란 무엇인가?

---

### 🔹 (1) 사토시(Satoshi)란?

**1 사토시(Sat)** = **비트코인의 최소 단위**

```
1 BTC = 100,000,000 사토시 (10^8 사토시)

```

즉,

- 1 사토시 = 0.00000001 BTC
- 100,000,000 사토시 = 1 BTC

> 이름은 비트코인을 만든 사람 **‘사토시 나카모토(Satoshi Nakamoto)’**에서 따왔습니다.
> 

---

### 🔹 (2) 왜 “정수 단위”로 쓰는가?

비트코인 시스템 안에서는 **모든 금액이 ‘정수(integer)’로 표현**됩니다.

소수점 단위를 직접 다루지 않아요.

예를 들어 👇

| 사람의 시각 | 내부 저장 방식 |
| --- | --- |
| 0.015 BTC | 1,500,000 사토시 |
| 0.0845 BTC | 8,450,000 사토시 |
| 1 BTC | 100,000,000 사토시 |

이유는 다음과 같아요:

- **정확한 계산을 위해**
    
    → 부동소수점(floating point) 계산 오차를 방지하려고
    
- **모든 트랜잭션 금액이 정수 사토시 단위로 기록되기 때문**
    
    → 트랜잭션의 Output `value` 필드가 “정수형(Integer)”로 정의되어 있습니다.
    

---

### 🔹 (3) 언제부터, 왜 이런 단위를 썼는가?

비트코인 초창기(2009년 제네시스 블록부터)부터 이미 이렇게 설계되었습니다.

이유는 명확해요 👇

1. **통화처럼 나눌 수 있게 하되, 유한한 단위로 정의해야 했기 때문**
    - BTC는 총 발행량이 21,000,000개로 한정되어 있으므로
        
        가장 작은 단위까지 세밀히 쪼개기 위해 1억 단위로 설계함.
        
2. **컴퓨터 연산 안정성**
    - 금융 거래처럼 정밀도가 중요하므로 “정수 단위”로 처리하면 오차가 없습니다.

---

✅ **정리**

| 개념 | 설명 |
| --- | --- |
| **사토시(Satoshi)** | 비트코인의 최소 단위 (1 sat = 0.00000001 BTC) |
| **정수 단위** | 트랜잭션 내부에서는 정수형 값으로 저장됨 (예: 1,500,000 sat) |
| **이유** | 연산 오차 방지, 금액 정밀 표현, 통화 단위 관리 |

---

📘 **요약 정리**

| 질문 | 답변 요약 |
| --- | --- |
| **1. Full node는 누구인가요?** | 채굴자뿐 아니라 모든 검증 노드를 의미함. 네트워크 전체의 블록과 트랜잭션을 검증하며 UTXO를 추적 |
| **2. 정수 사토시 단위란?** | BTC의 최소 단위(1 sat = 10^-8 BTC). 트랜잭션에서는 금액을 항상 정수 사토시 단위로 기록하여 연산 오차 방지 |

---

거래 입력 ▪ 비트코인 애플리케이션은 구매 금액을 충족하기 위해 여러 전략을 사용할 수 있습니다– 여러 작은 단위를 결합– 정확한 금액 찾기– 거래 금액보다 큰 단일 단위를 사용하고 거스름돈 만들기 ▪ 이러한 선택은 사용자의 지갑에서 자동으로 이루어지며 사용자가 볼 수 없습니다 ▪ 거래는 이전에 기록된 UTXO를 사용하고 새로운 거래 출력을 생성합니다

거래 출력 ▪ 코인베이스 거래– 특별한 유형의 거래 – 각 블록의 첫 번째 거래– 승리한 채굴자가 배치– 채굴에 대한 보상– UTXO를 소비하지 않음

▪ 새로운 거래는 UTXO 집합에서 하나 이상의 출력을 소비함 ▪ 거래 출력은 두 부분으로 구성됨 – 비트코인 금액: 사토시 단위로 표시 – 암호화 퍼즐: 출력을 사용하기 위해 필요한 조건을 결정함. 잠금 스크립트(locking script), 증인 스크립트(witness script), scriptPubKey라고도 함

# 1) 코인베이스 거래(coinbase transaction)

**무엇?**

- **특별한 거래**로, **각 블록의 첫 번째 거래**입니다.
- *채굴자(블록을 만든 노드)**가 직접 만들고 블록에 넣습니다.
- **입력(Input)이 없습니다.**(= 기존 UTXO를 소비하지 않음)
- 대신 **새 비트코인(블록 보상)**과 **그 블록에 포함된 모든 거래 수수료의 합**을 **출력(Output)**으로 생성해 **자기 주소(들)**로 보냅니다.
- 이때 생긴 출력들은 UTXO 집합에 **추가**됩니다.
    
    *(참고: 코인베이스로 받은 코인은 일정 블록 수가 지난 뒤에야(성숙, maturity) 쓸 수 있습니다.)*
    

**왜 중요한가?**

- 비트코인의 신규 발행은 **오직 코인베이스 거래**를 통해서만 일어납니다.
- 코인베이스는 **UTXO를 소비하지 않고 UTXO만 만든다**는 점이, 일반 거래와 가장 큰 차이입니다.

---

# 2) “새로운 거래는 UTXO 집합에서 하나 이상의 출력을 소비”

일반 거래는 항상 다음 과정을 밟습니다.

1. **입력(Input)**: 이전에 “사용되지 않은 출력(UTXO)”을 **참조**합니다.
    - `txid + vout(인덱스)`로 “어느 출력”을 쓰는지 지정
2. *해제 자료(언락 데이터)**를 제출합니다.
    - 서명·퍼블릭키 등으로 “이 UTXO를 쓸 권리”를 증명
3. *출력(Output)**을 새로 만듭니다.
    - 수신자(들)에게 보낼 금액 + 본인 잔돈(Change)
4. 노드는 **참조된 UTXO들을 ‘소비됨(spent)’으로 표시**하고,
    
    **새 출력들을 UTXO 집합에 ‘추가’**합니다.
    
    - 수수료 = **총입력 − 총출력**

즉, 모든 일반 거래는 “UTXO 집합을 **빼고(소비)** + **더하고(생성)**”로 업데이트합니다.

---

# 3) 거래 출력(Output)은 두 부분으로 이루어짐

각 **출력(vout)**에는 반드시 두 가지가 들어갑니다.

## (a) 금액(value)

- **정수 사토시** 단위로 저장됩니다.
    - 1 사토시 = 0.00000001 BTC
    - 예: 0.015 BTC → 1,500,000 사토시

## (b) 암호화 퍼즐(조건) = **잠금 스크립트(locking script)**

- 이 출력을 **나중에 사용할 수 있으려면** 충족해야 할 조건을 **스크립트**로 기록해 둡니다.
- 이 필드를 전통적으로 **`scriptPubKey`*라고 부릅니다.
- 세그윗(블록 구조 개편) 이후, 조건 충족을 위한 서명·증거는 **witness 영역**에 실리기도 해서 **witness script**라는 표현도 씁니다.
    - 핵심은 **“출력에는 ‘잠금 조건’이 들어 있고, 나중에 쓸 때는 그 조건을 ‘해제(언락)’하는 데이터를 제출”**한다는 점입니다.

### 가장 흔한 예: P2PKH(전통적인 주소의 잠금 스크립트)

- **잠금(`scriptPubKey`)**
    
    ```
    OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
    
    ```
    
    “해당 퍼블릭키 해시와 일치하고, 서명이 유효해야 쓸 수 있다”
    
- **해제(지출 시 제출하는 데이터)**
    - **서명(signature)** + **퍼블릭키(public key)**
        
        (레거시에선 `scriptSig`, 세그윗에선 witness 스택에 포함)
        

> 주소는 사람 친화적 표기일 뿐, 실제 블록체인에는 **퍼블릭키 해시(혹은 스크립트 해시)**가 잠금 조건 형태로 저장됩니다.
> 

---

# 4) 한눈에 보는 흐름

```
[코인베이스 거래]         [일반 거래]
- 입력: 없음              - 입력: 이전 UTXO 참조
- 출력: 보상+수수료       - 출력: 수신자 금액 + 잔돈
- 효과: UTXO만 생성       - 효과: 참조 UTXO 소모 + 새 UTXO 생성

```

예시(숫자 가볍게):

- 앨리스가 0.8 BTC UTXO 1개를 가지고 있고, 밥에게 0.3 BTC 전송
    - 입력: 앨리스의 0.8 BTC UTXO
    - 출력1: 밥 0.3 BTC
    - 출력2: 앨리스 잔돈 0.4995 BTC
    - 수수료: 0.0005 BTC
        
        → 노드는 0.8 BTC UTXO를 **소비**로 표시하고, 0.3 / 0.4995 두 UTXO를 **추가**합니다.
        

---

# 5) 용어 요약

- **코인베이스 거래**: 블록 첫 거래, 입력 없음, 보상·수수료를 새 UTXO로 **발행**.
- **UTXO 집합**: “아직 쓰이지 않은 모든 출력”의 현재 스냅샷. 풀 노드가 유지.
- **잠금 스크립트(scriptPubKey / locking script)**: “이 출력을 쓰려면 이런 조건을 만족해라”라는 규칙.
- **해제 데이터(scriptSig / witness)**: 실제로 쓸 때 제출하는 서명·퍼블릭키 등.
- **witness script**: 세그윗 계열에서 조건 충족을 증명하는 스크립트/데이터가 실리는 영역(특히 P2WSH 등에서 스크립트 본문을 witness로 제시).

---

트랜잭션 직렬화 - 출력 ▪ 트랜잭션이 네트워크를 통해 전송될 때 직렬화됩니다 ▪ 역직렬화(=트랜잭션 파싱) – 바이트 스트림 표현을 라이브러리의 내부 표현 데이터 구조로 변환

거래 직렬화 - 출력 ▪ 앨리스의 직렬화된 거래 출력 – 강조 표시된 섹션에 두 개의 출력

거래 입력 ▪ 거래 입력은 어떤 UTXO가 사용될 것인지 식별하고 잠금 해제 스크립트를 통해 소유권 증명을 제공합니다 ▪ 입력에는 네 가지 요소가 포함됩니다– 1.“거래 ID”: 사용될 UTXO를 포함하는 거래를 참조 2.“출력 인덱스(vout)” 3. “scriptSig “: UTXO에 부여된 조건을 만족시켜 사용 가능하게 함 4.“시퀀스 번호”

▪ 우리는 해당 UTXO에 대해 거래 ID 외에는 아무 것도 알지 못합니다. 따라서 정보를 얻고 이 거래에서 지불될 수수료를 계산하기 위해 참조된 UTXO를 사용해야 합니다 ▪ 거래를 디코딩할 때마다, 코드가 먼저 블록체인에서 참조된 UTXO를 가져와야 합니다

---

<img width="1729" height="677" alt="image" src="https://github.com/user-attachments/assets/e1e8db19-a079-47e1-a82d-f9e890422508" />

<img width="1732" height="617" alt="image" src="https://github.com/user-attachments/assets/1f8d9b13-791b-43e3-b517-3f4c5243c382" />


---

좋아요! 두 표는 **비트코인 트랜잭션을 바이트 단위로 직렬화(serialize)했을 때의 필드 구성**을 보여줍니다.

위 표는 **출력(Output / vout)**, 아래 표는 **입력(Input / vin)** 구조예요.

---

## ① Transaction **Output** (vout) 표 설명

출력은 “**새 UTXO를 만든다**”는 뜻이고, 각 vout은 두 가지 정보로 이뤄집니다.

- **Amount — 8 bytes, little-endian**
    - 이 출력의 금액. **정수 사토시**(1 sat = 10⁻⁸ BTC)로 저장.
    - 예) 0.015 BTC → 1,500,000 sats를 8바이트 LE로 기록.
- **Locking-Script Size — VarInt (1/3/5/9 bytes)**
    - 바로 뒤에 오는 스크립트의 길이(바이트 수).
    - VarInt 규칙:
        - < 0xFD → 1바이트 그대로
        - ≤ 0xFFFF → 0xFD + 2바이트(LE)
        - ≤ 0xFFFFFFFF → 0xFE + 4바이트(LE)
        - 그 이상 → 0xFF + 8바이트(LE)
- **Locking-Script — variable**
    - **이 UTXO를 나중에 쓰려면 만족해야 하는 조건**(= 잠금 스크립트, `scriptPubKey`).
    - 예) 전통 P2PKH는
        
        `OP_DUP OP_HASH160 <20-byte pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` (보통 25바이트)
        

> 요약: Output = 금액(사토시) + 잠금 조건(scriptPubKey) → “이 조건을 풀면 이 금액을 쓸 수 있다”는 뜻의 새 UTXO가 만들어집니다.
> 

---

## ② Transaction **Input** (vin) 표 설명

입력은 “**이전의 특정 UTXO를 소비한다**”는 뜻이고, 어떤 걸 쓰는지와 **그걸 쓸 권리 증명**을 담습니다.

- **Transaction Hash — 32 bytes**
    - **소비하려는 UTXO가 들어 있는 이전 트랜잭션의 해시(txid)**.
    - 직렬화 시 **리틀엔디언 바이트 순서**(탐색기 화면의 표기와 바이트 순서가 반대).
- **Output Index — 4 bytes**
    - 그 트랜잭션에서 **몇 번째 vout**을 쓰는지(0부터 시작).
    - 즉 “`txid`의 `vout[index]`를 소비한다”는 참조.
- **Unlocking-Script Size — VarInt**
    - 아래 `Unlocking-Script`의 길이.
- **Unlocking-Script — variable**
    - **잠금 조건을 만족시킨다는 증거**(= 해제 스크립트).
    - 레거시에선 `scriptSig`(보통 서명 + 퍼블릭키).
    - *세그윗(P2WPKH/P2WSH 등)**에선 여기(=scriptSig)는 비워두거나 최소화하고, **증거는 별도의 witness 섹션**에 들어감.
- **Sequence Number — 4 bytes**
    - **락타임/상대적 락타임(BIP-68) 등**에 쓰이는 필드.
    - `0xFFFFFFFF`면 **locktime 비활성(최종/final)**로 간주.

> 요약: Input = (이전 UTXO 위치: txid+index) + 그 UTXO를 쓸 권리 증명(scriptSig/witness) + sequence
> 
> 
> 노드는 이 입력이 가리키는 UTXO가 존재/미사용인지, 증명이 유효한지 검증한 뒤 소비로 표시합니다.
> 

---

## 연결해서 이해하기

- 한 **트랜잭션**은 여러 **입력(vin)**으로 **과거 UTXO를 소비**하고, 여러 **출력(vout)**으로 **새 UTXO를 생성**합니다.
- 그래서 “잔액”은 계정처럼 저장되지 않고, **내 지갑이 보유한 UTXO들의 합**으로 계산됩니다.

> 참고
> 
> - **코인베이스 입력**은 예외적으로 **이전 txid가 전부 0, index=0xFFFFFFFF**, `scriptSig`에는 채굴자 임의 데이터(블록 높이/엑스트라논스 등)가 들어갑니다.
> - **세그윗** 트랜잭션은 위 구조 + **witness 영역**(각 input마다 별도로 서명·증거 바이트)까지 함께 직렬화됩니다.

거래 수수료 ▪ 대부분의 거래에는 네트워크를 보호하는 비트코인 채굴자에 대한 보상으로 수수료가 포함됩니다 ▪ 대부분의 지갑은 거래 수수료를 자동으로 계산하고 포함하지만, 직접 거래를 구성하거나 CLI를 사용하는 경우 수수료를 수동으로 계산하고 포함해야 합니다 ▪ 거래 수수료는 비트코인 금액이 아닌 거래의 킬로바이트 크기를 기준으로 계산됩니다(→ 그래서 input을 잔돈 UTXO 여러 개를 모아서 계산하게 될 경우에 transaction 길이가 길어져서 수수료가 커질 수 있음.) ▪ 거래 수수료는 필수 사항이 아니지만, 수수료를 포함하면 우선 처리에 도움이 됩니다

모든 비트코인 서비스는 동적 수수료를 구현해야 합니다 – 제3자 서비스를 통해 구현하거나 내장 알고리즘으로 구현 가능 ▪ 수수료는 거래가 선택될 확률을 높여줍니다 ▪ 많은 지갑 애플리케이션이 수수료 계산을 위해 제3자 서비스를 사용합니다

---





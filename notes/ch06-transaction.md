# Ch06. Transaction

## p.2 - Transaction

Q. 강의자료에 '거래 ▪ 앨리스 주소에서 밥 주소로 이루어지는 거래 – 거래에 포함된 내용을 단순화하여 본 것'라는 내용이 있거든? 근데, 나는 '프라이빗키는 비트코인을 사용하기 위한 것, 퍼블릭키는 서명에 대한 유효성을 확인하기 위한 것, 주소는 비트코인을 받기 위해 상대에게 보여주기 위한 것'이라고 알고 있단 말이야. 그런데, 왜 '앨리스 주소에서 밥 주소로 이루어지는 거래'라는거야? 비트코인을 받을 밥만 주소가 필요한 거 아니야? 비트코인을 주는 앨리스는 왜 주소가 필요한거야?

### 1️⃣ 기본 개념 복습

- **프라이빗 키(private key)**: 내 돈을 쓰기 위한 열쇠. 절대 다른 사람에게 알려주면 안 됨.
- **퍼블릭 키(public key)**: 내 프라이빗 키와 짝을 이루는 공개키. 서명을 검증할 때 사용됨.
- **주소(address)**: 비트코인을 보내거나 받을 때 상대방에게 알려주는 식별자. 퍼블릭 키를 해싱해서 만든 것.

정리하면:

- **받을 때**: 상대에게 내 주소를 알려주면 됨.
- **보낼 때**: 내 프라이빗 키로 거래에 서명해야 함.

---

### 2️⃣ 거래(transaction)가 ‘앨리스 주소 → 밥 주소’로 표현되는 이유

교재나 강의에서 "앨리스 주소에서 밥 주소로 이루어지는 거래"라고 말하는 건, **거래의 흐름을 단순하게 시각화한 표현**이에요. 실제로는 이런 과정이 일어납니다:

1. **앨리스가 비트코인을 보냄**
    - 앨리스는 **자신의 UTXO(사용 가능한 비트코인 잔액)**를 사용합니다.
    - 거래에 서명할 때 **앨리스의 프라이빗 키**로 서명합니다.
2. **거래 정보에 기록**
    - 거래에는 ‘입력(Input)’과 ‘출력(Output)’이 있어요.
        - 입력: 앨리스가 소유한 코인 정보
        - 출력: 밥의 주소와 전송 금액
3. **밥이 받음**
    - 밥은 자신의 **주소를 출력(Output)**으로 등록해둡니다.
    - 이제 블록체인에 밥의 주소로 코인이 기록됨.

즉, 거래에서 앨리스의 **주소가 필요한 이유**는 단순히 “보낸 사람 누구인지, 어떤 코인을 사용했는지”를 기록하고, 블록체인상에서 **UTXO를 추적**하기 위해서예요.

- 앨리스의 주소 = 어떤 UTXO가 사용됐는지 나타내는 표시
- 밥의 주소 = 누구에게 보내는지 나타내는 표시

그래서 **교과서처럼 ‘앨리스 주소 → 밥 주소’**라고 쓰는 거예요. 실제로 앨리스는 자신의 주소를 모를 필요는 없지만, 거래 기록에는 넣어야 블록체인이 금액 흐름을 추적할 수 있어요.

---

### 3️⃣ 핵심 포인트

- 주소는 받는 사람만 필요한 게 아니라, **보낸 사람도 거래 기록을 위해 필요함**
- 프라이빗 키는 **서명**에 쓰임 → 앨리스만 서명 가능
- 퍼블릭 키/주소는 **검증**과 **식별**에 쓰임 → 누구에게서 누구에게 갔는지 기록

---



<img width="1526" height="857" alt="image" src="https://github.com/user-attachments/assets/07a6b6ec-1e23-4b28-9049-14c9a5e35408" />


좋아요. 이 이미지는 **비트코인 거래(Transaction)**의 세부 정보를 보여주는 블록 탐색기 화면 예시입니다. 각각의 항목을 하나씩 풀어서 설명드릴게요.

---

## 🧾 전체 구조 요약

비트코인은 “**입력(Input)** → **출력(Output)**”의 형태로 거래를 기록합니다.
즉, **이전 거래의 결과(출력)**를 **다음 거래의 입력**으로 사용하는 구조예요.

이 화면은 하나의 거래(transaction)가

* **어디서 왔는지(Inputs)**,
* **어디로 갔는지(Outputs)**,
* **얼마나의 수수료가 있었는지**
  등을 시각화한 것입니다.

---

## 📦 상단 영역

### **Transaction ID (TxID)**

```
0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2
```

* 이 거래를 고유하게 식별하는 해시값입니다.
* 거래가 블록체인에 기록되면 이 해시로 검색할 수 있습니다.

---

## 🟦 왼쪽 (Input, “보내는 쪽”)

```
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output)
```

* **이전 거래의 출력(Output)**을 **이번 거래의 입력(Input)**으로 사용한 주소입니다.
* 즉, “이 주소의 비트코인을 사용해서 새 거래를 만든 것”입니다.
* 이 주소는 “보내는 사람(앨리스)”의 주소에 해당합니다.
* `(0.1 BTC - Output)`은 이 주소에서 이전에 받은 코인이 0.1 BTC였다는 뜻입니다.

> **즉:** 앨리스가 과거에 0.1 BTC를 받았고, 지금 이걸 사용해서 보낸 거래라는 뜻이에요.

---

## 🟩 오른쪽 (Output, “받는 쪽”)

```
1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA   0.015 BTC (Unspent)
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK   0.0845 BTC (Unspent)
```

* 이번 거래의 결과로 **두 개의 출력(Output)**이 생성되었습니다.

| 주소                                   | 설명                      | 금액         |
| ------------------------------------ | ----------------------- | ---------- |
| `1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA` | **받는 사람(밥)**의 주소        | 0.015 BTC  |
| `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | **보내는 사람(앨리스)의 잔돈 주소)** | 0.0845 BTC |

* 두 Output 모두 `(Unspent)` 상태인데, 이는 아직 사용되지 않았다는 뜻입니다.
* 밥은 0.015 BTC를 새로 받았고, 앨리스는 남은 0.0845 BTC를 자신에게 다시 돌려받았습니다.

---

## 📊 Summary (요약 정보)

| 항목                    | 설명                               |
| --------------------- | -------------------------------- |
| **Size**              | 거래 데이터 크기 (258 bytes)            |
| **Received Time**     | 거래가 전파된 시각 (2013-12-27 23:03:05) |
| **Included in Block** | 이 거래가 포함된 블록 번호 277316           |
| **Confirmations**     | 현재 블록 이후 97개의 블록이 쌓여 확정됨 (안전성↑)  |

---

## 💰 Inputs and Outputs (입출금 요약)

| 항목                           | 값          | 설명                   |
| ---------------------------- | ---------- | -------------------- |
| **Total Input**              | 0.1 BTC    | 앨리스가 사용한 코인 총액       |
| **Total Output**             | 0.0995 BTC | 수신자 + 잔돈 총액          |
| **Fees**                     | 0.0005 BTC | 수수료 (채굴자에게 지급)       |
| **Estimated BTC Transacted** | 0.015 BTC  | 실제 송금된 금액 (밥이 받은 금액) |

---

## 🧠 요약 정리

이 거래를 인간 언어로 번역하면 다음과 같습니다 👇

> **앨리스(1Cdid9...)가 밥(1GdK9...)에게 0.015 BTC를 보냈다.**
> 총 0.1 BTC를 사용했고,
> 0.0845 BTC는 거스름돈으로 자기 자신에게 돌려받았다.
> 0.0005 BTC는 거래 수수료로 소모되었다.

---


Q. 방금 그 사진 속에서 프라이빗키와 퍼블릭키가 어디에 쓰인거야? output에 있는 주소를 만들 때, 앨리스의 프라이빗키와 퍼블릭키가 사용된 건가?
'ncluded in Block: 이 거래가 포함된 블록 번호 277316'이고, 'Confirmations: 현재 블록 이후 97개의 블록이 쌓여 확정됨'이라면 블록 하나에는 여러 개의 transaction들이 있는 거고, 여러 개의 transaction들을 가진 블록들 97가 해당 블록 뒤로 97개나 체인되었다는 말인가?

## ✅ 1️⃣ 프라이빗키·퍼블릭키는 어디서 쓰였는가?

좋은 질문이에요 —

**“Output에 있는 주소를 만들 때 프라이빗키와 퍼블릭키가 사용된 거야?”** 라는 건 아주 근본적인 궁금증이에요.

정답은 **“퍼블릭키로 주소를 만든다”**이고,

**“프라이빗키는 거래를 ‘보낼 때’ 사용된다”** 입니다.

---

### 🔹 (1) Output에 표시된 주소가 만들어지는 과정

예를 들어, 사진 속의

```
1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA

```

이런 문자열이 **비트코인 주소**입니다.

이건 아래 과정을 거쳐 만들어집니다 👇

1. **퍼블릭키 생성**:
    
    프라이빗키(개인키)를 이용해 ECDSA(Elliptic Curve Digital Signature Algorithm)로 퍼블릭키를 생성.
    
    ```
    private key  →  public key
    
    ```
    
2. **퍼블릭키 해시화**:
    
    퍼블릭키를 SHA-256 → RIPEMD-160으로 해시해 짧게 만듦.
    
    (`Hash160(public key)`)
    
3. **주소 형식으로 인코딩(Base58Check)**
    
    네트워크 정보(예: 메인넷 0x00) + 해시 + 체크섬을 붙여
    
    `1GdK9Uzp...` 같은 주소 문자열이 만들어짐.
    

> 즉, Output에 있는 주소는 받는 사람의 퍼블릭키 해시를 사람이 보기 좋게 바꾼 문자열이에요.
> 

---

### 🔹 (2) 그럼 프라이빗키는 언제 쓰이냐?

- *보내는 사람(앨리스)**이 **새로운 거래를 만들 때**,

이전 Output을 Input으로 사용하면서 **“내가 이 코인을 쓸 권리가 있다”**는 것을 증명해야 해요.

그 증명 수단이 바로 **디지털 서명**이고,

이때 앨리스의 **프라이빗키로 거래에 서명**합니다.

- 거래 생성: “이전 Output(0.1BTC)을 써서 새로운 Output 두 개를 만들겠다.”
- 서명: 앨리스의 프라이빗키로 거래 전체에 전자서명.
- 검증: 네트워크의 다른 노드들은 **앨리스의 퍼블릭키**로 이 서명이 유효한지 확인.

즉 👇

| 역할 | 사용되는 키 | 설명 |
| --- | --- | --- |
| 주소 생성 | **퍼블릭키 (공개키)** | 주소는 퍼블릭키로부터 파생 |
| 거래 서명 | **프라이빗키 (개인키)** | 거래를 보낼 때 “내 돈임”을 증명 |

---

## ✅ 2️⃣ Confirmations의 의미 (블록 체인 구조)

> “Included in Block: 277316”
> 
> 
> “Confirmations: 97”
> 

이 두 줄을 정확히 이해하셨어요 👏

---

### 🔹 (1) 블록 하나에는 여러 개의 거래가 들어감

맞아요.

비트코인의 **하나의 블록(block)** 안에는 **수백~수천 개의 거래(transaction)**가 포함됩니다.

그래서

```
277316번 블록
└── Transaction 1
└── Transaction 2
└── Transaction 3
   ...

```

이런 식으로 기록되어 있죠.

---

### 🔹 (2) Confirmations = 이후에 붙은 블록 수

“Confirmations: 97”은

`277316번 블록`이 블록체인에 포함된 후,

그 뒤로 **97개의 블록이 더 이어졌다**는 뜻입니다.

즉, 현재 블록체인의 맨 끝은

```
277316 + 97 = 277413번째 블록

```

쯤이 되겠죠.

---

### 🔹 (3) 왜 확인(confirmation)이 중요할까?

비트코인 네트워크는 분산되어 있기 때문에,

새 블록이 생성될 때 **임시로 체인 분기가 생길 수** 있습니다.

그래서 비트코인은 보통 이렇게 간주해요 👇

| 확인 횟수 | 신뢰 수준 | 의미 |
| --- | --- | --- |
| 0 | 매우 위험 | 막 전송된 상태 (아직 블록에 포함 안됨) |
| 1~2 | 낮음 | 블록에 포함됐지만 확정은 아님 |
| 6 이상 | 매우 안전 | 거래가 되돌릴 수 없을 정도로 확정됨 |

사진에선 97회니까,

거래가 완전히 확정된 상태입니다 ✅

---

## 🧩 정리 요약

| 개념 | 설명 | 사진 속 예시 |
| --- | --- | --- |
| **퍼블릭키** | 주소 생성에 사용됨 | Output 주소 (`1GdK9...`)는 퍼블릭키 해시 기반 |
| **프라이빗키** | 거래 서명(보낼 때 증명)에 사용됨 | 앨리스가 Input을 사용할 때 서명 |
| **블록** | 여러 거래의 묶음 | 블록 277316에 포함됨 |
| **Confirmations 97** | 97개의 블록이 뒤에 추가됨 → 거래 확정 | 매우 안전한 상태 |

---

Q. 그러면,
input에 있는 주소(1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output) )는 앨리스의 프라이빗키를 통해 사용을 증명할 수 있는거고,
사진 위쪽에 있던 0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2는 앨리스의 프라이빗키로 서명된 결과물이야?
output에 있던 1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA   0.015 BTC (Unspent), 1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK   0.0845 BTC (Unspent) 라는 두 주소는 각각 앨리스와 밥의 퍼블릭키를 통해 만들어진거야?

## 🧩 1️⃣ Input에 있는 주소는 앨리스의 프라이빗키로 사용을 증명한다 — ✅ **맞습니다**

```
1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK (0.1 BTC - Output)

```

이건 **이전 거래의 Output**, 즉 **앨리스가 과거에 받았던 비트코인**이에요.

앨리스가 이걸 지금 **Input으로 사용한다**는 건,

“이 0.1 BTC는 내 거니까 내가 쓸게”를 증명하는 행위죠.

그 증명 수단이 바로 **앨리스의 프라이빗키로 한 전자서명(digital signature)** 입니다.

즉,

> 앨리스의 프라이빗키로 ‘이 Input을 내가 쓰는 거래다’라는 메시지를 서명함
> 
> 
> → 네트워크의 모든 노드가 앨리스의 퍼블릭키로 서명 유효성 검증
> 
> → 유효하면 “아, 이건 진짜 앨리스가 쓴 거래네” 하고 인정
> 

요약하자면

- Input 주소는 퍼블릭키 해시 형태로 저장되어 있고,
- **그 주소의 주인이 실제로 코인을 쓸 때 프라이빗키로 서명**해야 합니다 ✅

---

## 🧾 2️⃣ “0627052b6f28912f...” 은 앨리스의 프라이빗키로 서명된 결과물인가? — ❌ **직접적으로는 아닙니다**

이 부분이 헷갈리기 쉬워요.

이 긴 문자열은 **거래 전체(Transaction)의 식별자**, 즉 **트랜잭션 해시(Transaction ID, TxID)**입니다.

```
0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2

```

이건 **앨리스의 프라이빗키로 만든 서명 결과물이 아니라**,

**“거래 데이터 전체를 해시한 값”**이에요.

즉 👇

| 항목 | 설명 |
| --- | --- |
| **디지털 서명(Signature)** | 앨리스의 프라이빗키로 생성됨. 거래의 일부에 포함됨. |
| **트랜잭션 ID(TxID)** | 거래 전체(입력·출력·서명 포함)를 해시(SHA-256x2)한 결과. |

서명은 거래 안쪽에 포함되어 있고,

TxID는 거래 전체의 “요약 해시”입니다.

따라서

> “TxID는 앨리스의 프라이빗키로 서명된 결과물”이 아니라,
> 
> 
> “프라이빗키 서명이 포함된 거래 전체를 SHA-256으로 두 번 해싱한 식별자”입니다.
> 

---

## 🎯 3️⃣ Output의 두 주소는 앨리스와 밥의 퍼블릭키 기반으로 만들어진 거야? — ✅ **정확합니다**

사진의 Output 두 개를 보면 👇

| 주소 | 금액 | 주인 | 설명 |
| --- | --- | --- | --- |
| `1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA` | 0.015 BTC | **밥(Bob)** | 밥이 새로 받는 코인 (송금 대상) |
| `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | 0.0845 BTC | **앨리스(Alice)** | 앨리스가 돌려받는 잔돈 (change) |

이 두 주소 모두 **각자의 퍼블릭키를 해시해서 만든 주소**예요.

즉:

- 밥은 `publicKey_Bob → hash160 → address_Bob`
- 앨리스는 `publicKey_Alice → hash160 → address_Alice`

그 결과로 저 두 Output 주소가 생깁니다.

그리고 거래가 블록체인에 기록될 때

Output에는 **퍼블릭키 해시(public key hash)**가 저장돼요.

다음에 이 Output을 누군가 쓰려면

그 퍼블릭키와 그에 대한 유효한 서명을 함께 제시해야 합니다.

---

## 💡 요약 정리

| 구분 | 대상 | 관련 키 | 설명 |
| --- | --- | --- | --- |
| **Input** | `1Cdid9KFAaatwczBwBttQcwxYCpvK8h7FK` | **프라이빗키(서명 시 사용)** | 앨리스가 과거 Output을 사용하는 것. “내 돈임”을 프라이빗키 서명으로 증명 |
| **TxID** | `0627052b6f...` | ❌ (서명 아님) | 거래 전체 데이터를 해시한 식별자 (SHA-256x2) |
| **Output** | `1GdK9UzpHB...`, `1Cdid9KFA...` | **퍼블릭키 기반 주소** | 밥과 앨리스의 퍼블릭키로부터 만들어진 새 주소들 |
| **서명(Signature)** | 거래 내부 필드 중 하나 | **앨리스의 프라이빗키** | TxID 생성엔 포함되지만, 그 자체가 TxID는 아님 |

---

## p.3 Transaction – behind the scenes

<img width="1669" height="1139" alt="image" src="https://github.com/user-attachments/assets/b6bcac18-6cdd-4ffd-beee-cf3a1500e050" />

좋아요 👍

이 슬라이드는 **“비트코인 트랜잭션의 실제 내부 구조(로우 데이터)”**를 보여주면서,

**우리가 평소에 생각하는 개념(코인, 송신자, 수신자, 계좌 등)은 사실 블록체인 내부에는 존재하지 않는다**는 걸 강조하는 자료입니다.

하나씩 뜯어볼게요 👇

---

## 🧩 1️⃣ 제목: “Transaction – behind the scenes”

👉 “트랜잭션의 이면(내부 구조)”

즉, 우리가 보기 좋은 형태(‘앨리스가 밥에게 0.015 BTC를 보냄’)가 아니라

**실제 블록체인에 저장되는 트랜잭션의 원시 데이터(raw data)**를 보여주는 슬라이드입니다.

---

## 🧾 2️⃣ 왼쪽 JSON 구조 설명

이건 실제 비트코인 트랜잭션의 원시 데이터(JSON 비슷한 구조로 표현)예요.

거래의 핵심 필드들을 포함하고 있습니다.

### ▶ `"vin"` (inputs)

```json
"vin": [
  {
    "txid": "7957a35f...999f6f18",
    "vout": 0,
    "scriptSig": "30450221...8d752adf",
    "sequence": 4294967295
  }
]

```

- **`txid`**: 이 Input이 참조하는 이전 거래의 ID
    
    → “어떤 Output을 가져와 쓰는가”를 나타냄
    
- **`vout`**: 그 거래에서 몇 번째 Output을 사용하는가 (0이면 첫 번째 Output)
- **`scriptSig`**: 바로 여기!
    
    👉 **보내는 사람의 프라이빗키 서명(Signature)** + **퍼블릭키**가 들어있음
    
    이걸 통해 “이 Output을 쓸 권리가 내게 있다”를 증명함.
    

> 즉, “앨리스의 프라이빗키가 실제로 쓰이는 부분”이 바로 scriptSig.
> 

---

### ▶ `"vout"` (outputs)

```json
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab6802... OP_EQUALVERIFY OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a... OP_EQUALVERIFY OP_CHECKSIG"
  }
]

```

- **`value`**: 전송되는 비트코인 양 (0.015 BTC, 0.0845 BTC)
- **`scriptPubKey`**: **받는 사람의 주소(퍼블릭키 해시)**를 이용한 잠금 스크립트

이 스크립트는 “이 코인을 사용하려면 다음 조건을 만족해야 한다”를 정의합니다:

```
OP_DUP OP_HASH160 <publicKeyHash> OP_EQUALVERIFY OP_CHECKSIG

```

→ 즉, “퍼블릭키 해시가 일치하고, 서명이 유효해야 사용 가능하다”는 조건.

---

## 🧠 3️⃣ 오른쪽 문장 해석

> “no coins, no senders, no recipients, no balances, no accounts, and no address!”
> 

이 문장은 핵심 메시지를 설명합니다 👇

| 우리가 생각하는 것 | 실제로는 존재하지 않음 |
| --- | --- |
| 💰 “코인” | 없음 — 단지 입력과 출력 스크립트로 표현됨 |
| 🧍 “보내는 사람(sender)” | 없음 — 단지 이전 Output의 소유자가 서명함 |
| 🧑‍🤝‍🧑 “받는 사람(recipient)” | 없음 — 단지 퍼블릭키 해시로 새 Output이 잠김 |
| 🏦 “잔액(balance)” | 없음 — 모든 Output을 합산해서 계산해야 함 |
| 🧾 “계좌(account)” | 없음 — 주소는 단순한 퍼블릭키 해시일 뿐 |
| 📬 “주소(address)” | 고수준에서 사람이 보기 쉽게 인코딩한 것일 뿐, 내부에는 없음 |

즉, 비트코인은 **“계정 기반 시스템(account-based)”이 아니라 “UTXO 기반 시스템”**이에요.

이 원시 데이터에는 단지

- 어떤 트랜잭션의 어떤 Output을 썼는지 (`txid`, `vout`)
- 어떤 조건으로 새 Output을 만들었는지 (`scriptPubKey`)
- 그 사용이 유효함을 증명하는 서명 (`scriptSig`)
    
    이 정보만 들어있을 뿐이에요.
    

---

## 🧩 4️⃣ 요약하면

이 슬라이드가 전하려는 핵심은 다음과 같습니다 👇

> 비트코인 트랜잭션의 내부에는 “사람이 이해하기 쉬운 개념”이 없다.
> 
> 
> 실제로 존재하는 것은 오직 **입력(Input)**, **출력(Output)**, **스크립트(script)**, **서명(signature)** 뿐이다.
> 
> 우리가 말하는 “보내는 사람 / 받는 사람 / 주소 / 잔액”은
> 
> 모두 이 데이터 위에서 **소프트웨어가 해석해서 보여주는 추상 개념**일 뿐이다.
> 

---

거래 출력 ▪ 비트코인 거래의 기본 구성 요소는 거래 출력입니다 ▪ 비트코인 풀 노드는 UTXO를 추적합니다 – UTXO: 미사용 거래 출력 ▪ 모든 거래는 UTXO 집합의 변화를 나타냅니다 ▪ 사용자의 비트코인 잔액은 사용자의 지갑이 사용할 수 있는 모든 UTXO의 합계입니다 ▪ 출력은 개별적이고 나눌 수 없는 가치 단위로, 정수 사토시 단위로 표시됩니다 (1 사토시 = 0.00000001(10^-8) BTC) – 결과적으로 대부분의 비트코인 거래는 잔돈을 생성해야 합니다

‘비트코인 풀 노드는 UTXO를 추적합니다’에서 full node는 채굴자들을 의미하는 건가요? 아니면, 자신의  UTXO를 사용하려는 앨리스를 의미하는 건가요?

‘정수 사토시 단위’가 뭔가요? 언제부터, 왜 쓰는 단위인가요?

## 🧩 1️⃣ “비트코인 풀 노드는 UTXO를 추적합니다” — 여기서 **풀 노드(full node)**란?

결론부터 말하면,

👉 **풀 노드는 채굴자(miner)**만을 의미하지 않습니다.

👉 **네트워크의 모든 검증 노드(즉, “전체 블록체인을 직접 검증하는 사용자”)**를 의미합니다.

---

### 🔹 (1) 풀 노드(Full Node)의 정의

- *풀 노드(Full Node)**란:
- 비트코인 네트워크의 모든 블록과 트랜잭션을 **직접 다운로드하고 검증**하는 컴퓨터를 말합니다.
- 블록체인의 모든 규칙(서명 유효성, 잔액, 중복 사용 등)을 스스로 검증할 수 있습니다.
- 비트코인의 **신뢰를 분산시키는 핵심 주체**예요.

즉, 풀 노드는

- 새 거래(Transaction)가 유효한지 확인하고,
- 블록이 규칙에 맞는지 검증하며,
- **현재 미사용 거래 출력(UTXO) 집합을 유지 관리**합니다.

---

### 🔹 (2) “채굴자(Miner)”와의 관계

| 구분 | 역할 | Full Node 포함 여부 |
| --- | --- | --- |
| **풀 노드 (Full Node)** | 블록과 트랜잭션을 **검증하고 저장**함 | ✅ 항상 UTXO 집합을 유지 |
| **채굴자 (Miner)** | 블록을 **생성**함 (새 거래를 블록에 넣고 보상 받음) | ✅ 대부분 풀 노드 기능을 포함함 |

즉,

- 모든 **채굴자**는 **풀 노드이기도 하지만**,
- 모든 **풀 노드**가 **채굴자**인 것은 아닙니다.

> 📌 비유하자면
> 
> 
> 풀 노드는 **법원**처럼 “이 거래가 유효한가?”를 판정하고,
> 
> 채굴자는 **기록원**처럼 “유효한 거래를 모아서 블록에 기록”하는 역할이에요.
> 

---

### 🔹 (3) 앨리스의 역할은?

앨리스는 “자신의 UTXO를 사용하려는 사용자”일 뿐이고,

직접 풀 노드를 운영하지 않아도 비트코인을 전송할 수 있어요.

일반적으로는 **지갑 프로그램(wallet)**이 풀 노드(혹은 라이트 노드)에 접속해서

자신의 거래를 네트워크에 브로드캐스트합니다.

즉 👇

- **풀 노드**: 네트워크의 심판자, 전체 블록을 검증하며 UTXO를 추적
- **앨리스(사용자)**: 자신의 지갑을 통해 거래를 생성하고, 풀 노드에게 전달

---

✅ **정리**

> “비트코인 풀 노드는 UTXO를 추적한다”
> 
> 
> → 여기서 말하는 풀 노드는 **채굴자와 일반 검증 노드를 모두 포함한,
> 전체 블록체인 검증 주체**를 의미합니다.
> 앨리스는 그 풀 노드에 거래를 전송하는 사용자일 뿐이에요.
> 

---

## 🪙 2️⃣ “정수 사토시 단위”란 무엇인가?

---

### 🔹 (1) 사토시(Satoshi)란?

**1 사토시(Sat)** = **비트코인의 최소 단위**

```
1 BTC = 100,000,000 사토시 (10^8 사토시)

```

즉,

- 1 사토시 = 0.00000001 BTC
- 100,000,000 사토시 = 1 BTC

> 이름은 비트코인을 만든 사람 **‘사토시 나카모토(Satoshi Nakamoto)’**에서 따왔습니다.
> 

---

### 🔹 (2) 왜 “정수 단위”로 쓰는가?

비트코인 시스템 안에서는 **모든 금액이 ‘정수(integer)’로 표현**됩니다.

소수점 단위를 직접 다루지 않아요.

예를 들어 👇

| 사람의 시각 | 내부 저장 방식 |
| --- | --- |
| 0.015 BTC | 1,500,000 사토시 |
| 0.0845 BTC | 8,450,000 사토시 |
| 1 BTC | 100,000,000 사토시 |

이유는 다음과 같아요:

- **정확한 계산을 위해**
    
    → 부동소수점(floating point) 계산 오차를 방지하려고
    
- **모든 트랜잭션 금액이 정수 사토시 단위로 기록되기 때문**
    
    → 트랜잭션의 Output `value` 필드가 “정수형(Integer)”로 정의되어 있습니다.
    

---

### 🔹 (3) 언제부터, 왜 이런 단위를 썼는가?

비트코인 초창기(2009년 제네시스 블록부터)부터 이미 이렇게 설계되었습니다.

이유는 명확해요 👇

1. **통화처럼 나눌 수 있게 하되, 유한한 단위로 정의해야 했기 때문**
    - BTC는 총 발행량이 21,000,000개로 한정되어 있으므로
        
        가장 작은 단위까지 세밀히 쪼개기 위해 1억 단위로 설계함.
        
2. **컴퓨터 연산 안정성**
    - 금융 거래처럼 정밀도가 중요하므로 “정수 단위”로 처리하면 오차가 없습니다.

---

✅ **정리**

| 개념 | 설명 |
| --- | --- |
| **사토시(Satoshi)** | 비트코인의 최소 단위 (1 sat = 0.00000001 BTC) |
| **정수 단위** | 트랜잭션 내부에서는 정수형 값으로 저장됨 (예: 1,500,000 sat) |
| **이유** | 연산 오차 방지, 금액 정밀 표현, 통화 단위 관리 |

---

📘 **요약 정리**

| 질문 | 답변 요약 |
| --- | --- |
| **1. Full node는 누구인가요?** | 채굴자뿐 아니라 모든 검증 노드를 의미함. 네트워크 전체의 블록과 트랜잭션을 검증하며 UTXO를 추적 |
| **2. 정수 사토시 단위란?** | BTC의 최소 단위(1 sat = 10^-8 BTC). 트랜잭션에서는 금액을 항상 정수 사토시 단위로 기록하여 연산 오차 방지 |

---

거래 입력 ▪ 비트코인 애플리케이션은 구매 금액을 충족하기 위해 여러 전략을 사용할 수 있습니다– 여러 작은 단위를 결합– 정확한 금액 찾기– 거래 금액보다 큰 단일 단위를 사용하고 거스름돈 만들기 ▪ 이러한 선택은 사용자의 지갑에서 자동으로 이루어지며 사용자가 볼 수 없습니다 ▪ 거래는 이전에 기록된 UTXO를 사용하고 새로운 거래 출력을 생성합니다

거래 출력 ▪ 코인베이스 거래– 특별한 유형의 거래 – 각 블록의 첫 번째 거래– 승리한 채굴자가 배치– 채굴에 대한 보상– UTXO를 소비하지 않음

▪ 새로운 거래는 UTXO 집합에서 하나 이상의 출력을 소비함 ▪ 거래 출력은 두 부분으로 구성됨 – 비트코인 금액: 사토시 단위로 표시 – 암호화 퍼즐: 출력을 사용하기 위해 필요한 조건을 결정함. 잠금 스크립트(locking script), 증인 스크립트(witness script), scriptPubKey라고도 함

# 1) 코인베이스 거래(coinbase transaction)

**무엇?**

- **특별한 거래**로, **각 블록의 첫 번째 거래**입니다.
- *채굴자(블록을 만든 노드)**가 직접 만들고 블록에 넣습니다.
- **입력(Input)이 없습니다.**(= 기존 UTXO를 소비하지 않음)
- 대신 **새 비트코인(블록 보상)**과 **그 블록에 포함된 모든 거래 수수료의 합**을 **출력(Output)**으로 생성해 **자기 주소(들)**로 보냅니다.
- 이때 생긴 출력들은 UTXO 집합에 **추가**됩니다.
    
    *(참고: 코인베이스로 받은 코인은 일정 블록 수가 지난 뒤에야(성숙, maturity) 쓸 수 있습니다.)*
    

**왜 중요한가?**

- 비트코인의 신규 발행은 **오직 코인베이스 거래**를 통해서만 일어납니다.
- 코인베이스는 **UTXO를 소비하지 않고 UTXO만 만든다**는 점이, 일반 거래와 가장 큰 차이입니다.

---

# 2) “새로운 거래는 UTXO 집합에서 하나 이상의 출력을 소비”

일반 거래는 항상 다음 과정을 밟습니다.

1. **입력(Input)**: 이전에 “사용되지 않은 출력(UTXO)”을 **참조**합니다.
    - `txid + vout(인덱스)`로 “어느 출력”을 쓰는지 지정
2. *해제 자료(언락 데이터)**를 제출합니다.
    - 서명·퍼블릭키 등으로 “이 UTXO를 쓸 권리”를 증명
3. *출력(Output)**을 새로 만듭니다.
    - 수신자(들)에게 보낼 금액 + 본인 잔돈(Change)
4. 노드는 **참조된 UTXO들을 ‘소비됨(spent)’으로 표시**하고,
    
    **새 출력들을 UTXO 집합에 ‘추가’**합니다.
    
    - 수수료 = **총입력 − 총출력**

즉, 모든 일반 거래는 “UTXO 집합을 **빼고(소비)** + **더하고(생성)**”로 업데이트합니다.

---

# 3) 거래 출력(Output)은 두 부분으로 이루어짐

각 **출력(vout)**에는 반드시 두 가지가 들어갑니다.

## (a) 금액(value)

- **정수 사토시** 단위로 저장됩니다.
    - 1 사토시 = 0.00000001 BTC
    - 예: 0.015 BTC → 1,500,000 사토시

## (b) 암호화 퍼즐(조건) = **잠금 스크립트(locking script)**

- 이 출력을 **나중에 사용할 수 있으려면** 충족해야 할 조건을 **스크립트**로 기록해 둡니다.
- 이 필드를 전통적으로 **`scriptPubKey`*라고 부릅니다.
- 세그윗(블록 구조 개편) 이후, 조건 충족을 위한 서명·증거는 **witness 영역**에 실리기도 해서 **witness script**라는 표현도 씁니다.
    - 핵심은 **“출력에는 ‘잠금 조건’이 들어 있고, 나중에 쓸 때는 그 조건을 ‘해제(언락)’하는 데이터를 제출”**한다는 점입니다.

### 가장 흔한 예: P2PKH(전통적인 주소의 잠금 스크립트)

- **잠금(`scriptPubKey`)**
    
    ```
    OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
    
    ```
    
    “해당 퍼블릭키 해시와 일치하고, 서명이 유효해야 쓸 수 있다”
    
- **해제(지출 시 제출하는 데이터)**
    - **서명(signature)** + **퍼블릭키(public key)**
        
        (레거시에선 `scriptSig`, 세그윗에선 witness 스택에 포함)
        

> 주소는 사람 친화적 표기일 뿐, 실제 블록체인에는 **퍼블릭키 해시(혹은 스크립트 해시)**가 잠금 조건 형태로 저장됩니다.
> 

---

# 4) 한눈에 보는 흐름

```
[코인베이스 거래]         [일반 거래]
- 입력: 없음              - 입력: 이전 UTXO 참조
- 출력: 보상+수수료       - 출력: 수신자 금액 + 잔돈
- 효과: UTXO만 생성       - 효과: 참조 UTXO 소모 + 새 UTXO 생성

```

예시(숫자 가볍게):

- 앨리스가 0.8 BTC UTXO 1개를 가지고 있고, 밥에게 0.3 BTC 전송
    - 입력: 앨리스의 0.8 BTC UTXO
    - 출력1: 밥 0.3 BTC
    - 출력2: 앨리스 잔돈 0.4995 BTC
    - 수수료: 0.0005 BTC
        
        → 노드는 0.8 BTC UTXO를 **소비**로 표시하고, 0.3 / 0.4995 두 UTXO를 **추가**합니다.
        

---

# 5) 용어 요약

- **코인베이스 거래**: 블록 첫 거래, 입력 없음, 보상·수수료를 새 UTXO로 **발행**.
- **UTXO 집합**: “아직 쓰이지 않은 모든 출력”의 현재 스냅샷. 풀 노드가 유지.
- **잠금 스크립트(scriptPubKey / locking script)**: “이 출력을 쓰려면 이런 조건을 만족해라”라는 규칙.
- **해제 데이터(scriptSig / witness)**: 실제로 쓸 때 제출하는 서명·퍼블릭키 등.
- **witness script**: 세그윗 계열에서 조건 충족을 증명하는 스크립트/데이터가 실리는 영역(특히 P2WSH 등에서 스크립트 본문을 witness로 제시).

---

트랜잭션 직렬화 - 출력 ▪ 트랜잭션이 네트워크를 통해 전송될 때 직렬화됩니다 ▪ 역직렬화(=트랜잭션 파싱) – 바이트 스트림 표현을 라이브러리의 내부 표현 데이터 구조로 변환

거래 직렬화 - 출력 ▪ 앨리스의 직렬화된 거래 출력 – 강조 표시된 섹션에 두 개의 출력

거래 입력 ▪ 거래 입력은 어떤 UTXO가 사용될 것인지 식별하고 잠금 해제 스크립트를 통해 소유권 증명을 제공합니다 ▪ 입력에는 네 가지 요소가 포함됩니다– 1.“거래 ID”: 사용될 UTXO를 포함하는 거래를 참조 2.“출력 인덱스(vout)” 3. “scriptSig “: UTXO에 부여된 조건을 만족시켜 사용 가능하게 함 4.“시퀀스 번호”

▪ 우리는 해당 UTXO에 대해 거래 ID 외에는 아무 것도 알지 못합니다. 따라서 정보를 얻고 이 거래에서 지불될 수수료를 계산하기 위해 참조된 UTXO를 사용해야 합니다 ▪ 거래를 디코딩할 때마다, 코드가 먼저 블록체인에서 참조된 UTXO를 가져와야 합니다

---

<img width="1729" height="677" alt="image" src="https://github.com/user-attachments/assets/e1e8db19-a079-47e1-a82d-f9e890422508" />

<img width="1732" height="617" alt="image" src="https://github.com/user-attachments/assets/1f8d9b13-791b-43e3-b517-3f4c5243c382" />


---

좋아요! 두 표는 **비트코인 트랜잭션을 바이트 단위로 직렬화(serialize)했을 때의 필드 구성**을 보여줍니다.

위 표는 **출력(Output / vout)**, 아래 표는 **입력(Input / vin)** 구조예요.

---

<img width="1853" height="1058" alt="image" src="https://github.com/user-attachments/assets/1aa9815c-b816-4d24-8a4d-b111ab29c55b" />


## ① Transaction **Output** (vout) 표 설명

출력은 “**새 UTXO를 만든다**”는 뜻이고, 각 vout은 두 가지 정보로 이뤄집니다.

- **Amount — 8 bytes, little-endian**
    - 이 출력의 금액. **정수 사토시**(1 sat = 10⁻⁸ BTC)로 저장.
    - 예) 0.015 BTC → 1,500,000 sats를 8바이트 LE로 기록.
- **Locking-Script Size — VarInt (1/3/5/9 bytes)**
    - 바로 뒤에 오는 스크립트의 길이(바이트 수).
    - VarInt 규칙:
        - < 0xFD → 1바이트 그대로
        - ≤ 0xFFFF → 0xFD + 2바이트(LE)
        - ≤ 0xFFFFFFFF → 0xFE + 4바이트(LE)
        - 그 이상 → 0xFF + 8바이트(LE)
- **Locking-Script — variable**
    - **이 UTXO를 나중에 쓰려면 만족해야 하는 조건**(= 잠금 스크립트, `scriptPubKey`).
    - 예) 전통 P2PKH는
        
        `OP_DUP OP_HASH160 <20-byte pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` (보통 25바이트)
        

> 요약: Output = 금액(사토시) + 잠금 조건(scriptPubKey) → “이 조건을 풀면 이 금액을 쓸 수 있다”는 뜻의 새 UTXO가 만들어집니다.
> 

---

<img width="1561" height="901" alt="image" src="https://github.com/user-attachments/assets/1b8e0c18-8985-4749-ac07-1c40ac9d9b2d" />


## ② Transaction **Input** (vin) 표 설명

입력은 “**이전의 특정 UTXO를 소비한다**”는 뜻이고, 어떤 걸 쓰는지와 **그걸 쓸 권리 증명**을 담습니다.

- **Transaction Hash — 32 bytes**
    - **소비하려는 UTXO가 들어 있는 이전 트랜잭션의 해시(txid)**.
    - 직렬화 시 **리틀엔디언 바이트 순서**(탐색기 화면의 표기와 바이트 순서가 반대).
- **Output Index — 4 bytes**
    - 그 트랜잭션에서 **몇 번째 vout**을 쓰는지(0부터 시작).
    - 즉 “`txid`의 `vout[index]`를 소비한다”는 참조.
- **Unlocking-Script Size — VarInt**
    - 아래 `Unlocking-Script`의 길이.
- **Unlocking-Script — variable**
    - **잠금 조건을 만족시킨다는 증거**(= 해제 스크립트).
    - 레거시에선 `scriptSig`(보통 서명 + 퍼블릭키).
    - *세그윗(P2WPKH/P2WSH 등)**에선 여기(=scriptSig)는 비워두거나 최소화하고, **증거는 별도의 witness 섹션**에 들어감.
- **Sequence Number — 4 bytes**
    - **락타임/상대적 락타임(BIP-68) 등**에 쓰이는 필드.
    - `0xFFFFFFFF`면 **locktime 비활성(최종/final)**로 간주.

> 요약: Input = (이전 UTXO 위치: txid+index) + 그 UTXO를 쓸 권리 증명(scriptSig/witness) + sequence
> 
> 
> 노드는 이 입력이 가리키는 UTXO가 존재/미사용인지, 증명이 유효한지 검증한 뒤 소비로 표시합니다.
> 

---

거래 수수료 ▪ 대부분의 거래에는 네트워크를 보호하는 비트코인 채굴자에 대한 보상으로 수수료가 포함됩니다 ▪ 대부분의 지갑은 거래 수수료를 자동으로 계산하고 포함하지만, 직접 거래를 구성하거나 CLI를 사용하는 경우 수수료를 수동으로 계산하고 포함해야 합니다 ▪ 거래 수수료는 비트코인 금액이 아닌 거래의 킬로바이트 크기를 기준으로 계산됩니다(→ 그래서 input을 잔돈 UTXO 여러 개를 모아서 계산하게 될 경우에 transaction 길이가 길어져서 수수료가 커질 수 있음.) ▪ 거래 수수료는 필수 사항이 아니지만, 수수료를 포함하면 우선 처리에 도움이 됩니다

모든 비트코인 서비스는 동적 수수료를 구현해야 합니다 – 제3자 서비스를 통해 구현하거나 내장 알고리즘으로 구현 가능 ▪ 수수료는 거래가 선택될 확률을 높여줍니다 ▪ 많은 지갑 애플리케이션이 수수료 계산을 위해 제3자 서비스를 사용합니다

---

핵심은 “**수수료는 고정된 요금이 아니라, 사용자가 스스로 정하는 인센티브**”라는 거예요.

---

## 🧩 1️⃣ “수수료는 누가 결정하나요?”

👉 **수수료는 ‘보내는 사람(사용자)’이 결정합니다.**

즉, **앨리스가 비트코인을 보낼 때, ‘얼마를 수수료로 내겠다’는 걸 직접 설정하는 구조**예요.

비트코인 거래에서는 **“입력 합계(Input total)” − “출력 합계(Output total)”**
이 차이가 바로 수수료로 계산됩니다.

### 예시

```
입력(Input): 0.1 BTC
출력(Output1): 밥에게 0.0995 BTC
출력(Output2): 앨리스 잔돈 0.0000 BTC (없음)
→ 수수료 = 0.1 - 0.0995 = 0.0005 BTC
```

즉, **채굴자에게 얼마를 줄지는 송신자 마음**이에요.
지갑(월렛)이 자동 계산해주는 경우가 대부분이지만, 원리는 단순히 “Output을 조금 적게 써서 그 차액을 남긴다”입니다.

---

## 🧩 2️⃣ “그럼 채굴자가 받는 수수료는 어디서 오는 건가요?”

* 채굴자가 새 블록을 만들 때, 블록 안에 여러 거래를 포함시킵니다.
* 각 거래에는 **수수료(fee)**가 포함되어 있고,
  **그 모든 수수료 합계 + 블록 보상**이 채굴자의 수입이 됩니다.

> ✅ 즉, 수수료는 “사용자가 자발적으로 제시한 인센티브”이고,
> 채굴자는 그걸 보고 “내 블록에 넣을지 말지”를 결정합니다.

---

## 🧩 3️⃣ “왜 수수료는 금액이 아니라 거래 크기(킬로바이트 단위)로 계산되나요?”

비트코인은 **‘데이터 용량’ 기반 네트워크**이기 때문이에요.
채굴자는 한 블록(약 1MB)에 들어갈 거래를 선택해야 하는데,
그 공간이 한정되어 있으므로 “공간을 효율적으로 쓰는 거래”가 유리합니다.

* 수수료 단위는 “BTC per kilobyte” (BTC/kB) 혹은 “satoshi per byte (sat/vB)”
* 거래 크기가 커질수록(=입력 UTXO가 많을수록) 필요한 서명과 데이터가 많아져서 수수료가 커짐.

예시:

| 거래 형태         | 입력 수 | 크기        | 수수료 단가    | 총 수수료      |
| ------------- | ---- | --------- | --------- | ---------- |
| 간단 거래 (입력 1개) | 1    | 200 bytes | 30 sat/vB | 6,000 sat  |
| 잔돈 5개 합친 거래   | 5    | 900 bytes | 30 sat/vB | 27,000 sat |

> 즉, **“돈 액수”가 아니라 “거래 데이터 크기”**가 수수료를 결정합니다.

---

## 🧩 4️⃣ “수수료는 필수인가요?”

* **아니요.** 거래 자체는 수수료 없이도 만들 수 있어요.
* 하지만 수수료가 없으면 채굴자가 거래를 블록에 포함시킬 **동기(인센티브)**가 없어서,
  **네트워크에서 매우 늦게 처리되거나 아예 무시**될 수 있습니다.

그래서 실제로는 거의 모든 거래에 소량의 수수료가 포함됩니다.

---

## 🧩 5️⃣ “동적 수수료(Dynamic Fee)”란?

네트워크 상황(혼잡도, 블록 점유율 등)에 따라
적절한 수수료 수준이 계속 바뀌기 때문에,
지갑들은 보통 “**현재 네트워크 평균 수수료를 자동으로 반영하는 기능**”을 가지고 있습니다.

* 예: “빠른 전송(Fast)”, “보통(Normal)”, “느림(Slow)” 옵션
  → 각 옵션에 따라 sat/vB 단가를 달리 적용
  → 제3자 서비스(예: mempool.space, bitcoinfees.net)나 내장 알고리즘으로 계산

---

## 💡 쉽게 정리하면

| 개념             | 설명                                      |
| -------------- | --------------------------------------- |
| **누가 정하나요?**   | 비트코인 **보내는 사람이 직접 정함**                  |
| **채굴자는 뭘 하죠?** | 높은 수수료의 거래를 **먼저 선택**해 블록에 포함           |
| **왜 필요하죠?**    | 채굴자에게 보상(인센티브)을 주고, 내 거래를 빠르게 처리받기 위해   |
| **얼마나 내나요?**   | 거래 **데이터 크기(바이트)** 기준으로 계산 (금액이 아니라 용량) |
| **자동 계산은?**    | 대부분의 **지갑이 동적 수수료 기능**으로 자동 반영          |
| **안 내면?**      | 블록에 안 포함되거나, 처리 지연될 수 있음                |

---

---

거래 스크립트 및 스크립트 언어 ▪ 비트코인 거래 스크립트 및 스크립트 언어 - 잠금 스크립트(UTXO에 배치) - 잠금 해제 스크립트(각 입력에 포함)

거래 스크립트 및 스크립트 언어 ▪ 거래 스크립트  Turing Incompleteness: 조건부 흐름 제어 외에는 루프나 복잡한 흐름 제어 기능이 없음 - 이러한 제한은 언어가 무한 루프나 다른 형태의 '로직 폭탄'을 생성하는 데 사용될 수 없도록 보장하며, 이러한 로직 폭탄이 트랜잭션에 포함되어 비트코인 네트워크에 대한 서비스 거부 공격을 일으키는 것을 방지함  Stateless Verification: 스크립트는 어떤 시스템에서도 예측 가능하게 동일하게 실행됨. 시스템이 스크립트를 검증하면 비트코인 네트워크의 모든 다른 시스템도 스크립트를 검증할 수 있으며, 이는 유효한 트랜잭션이 모든 사용자에게 유효하고 모든 사용자가 이를 알고 있음을 의미함

▪  Script Construction(Lock + Unlock) - 비트코인의 트랜잭션 검증 엔진은 트랜잭션을 검증하기 위해 두 가지 유형의 스크립트, 즉 잠금 스크립트와 잠금 해제 스크립트에 의존합니다 ▪ Locking Script(scriptPubKey/cryptographic puzzle) - 잠금 스크립트는 출력에 설정된 지출 조건으로, 미래에 출력을 지출하려면 충족해야 하는 조건을 명시합니다 ▪  Unlocking Script(scriptSig) - 잠금 해제 스크립트는 잠금 스크립트가 출력에 설정한 조건을 "해결"하거나 만족시키는 스크립트로, 출력을 지출할 수 있게 해줍니다

---

핵심은 **“블록체인에 ‘조건(잠금)’을 걸어두고, 그걸 풀어야 돈을 쓸 수 있다”**는 개념이에요. 

---

## 1) 스크립트(스크립트 언어)란 무엇인가?

- *스크립트 = ‘조건문(작은 프로그램)’**이라고 보면 됩니다.
    
    트랜잭션의 출력(Output)에 **잠금 조건(locking script, scriptPubKey)** 을 넣어두고,
    
    그 출력을 쓰려면 입력(Input) 쪽에서 **그 조건을 풀어주는 데이터(unlocking script, scriptSig)** 를 제출해야 해요.
    

간단 비유:

- 출력 = “이 금고는 **비밀번호(퍼블릭키 해시)**를 맞춰야 연다”고 써놓은 금고
- 입력 = “여기 내 **비밀번호(서명 + 퍼블릭키)**” 를 보여주면 금고가 열린다

---

## 2) 잠금 스크립트와 잠금 해제 스크립트의 위치

- **잠금 스크립트 (Locking script / scriptPubKey)**
    
    → **출력(vout)** 안에 들어감. “나를 쓰려면 이런 조건을 만족해라” 라고 적어 둠.
    
- **잠금 해제 스크립트 (Unlocking script / scriptSig)**
    
    → **입력(vin)** 안에 들어감. “나는 이 조건을 이렇게 풀겠다(서명 등)” 라고 증거를 제공.
    

검증 엔진은 **(입력에 있는 scriptSig) + (출력에 있는 scriptPubKey)** 를 합쳐서 실행하고,

결과가 ‘참(유효)’이면 그 입력은 해당 출력을 소비(spend)할 수 있게 됩니다.

---

## 3) 스크립트 언어의 특징 — 왜 복잡하게 만들지 않았을까?

### (a) Turing Incompleteness (튜링 불완전성)

- 비트코인 스크립트는 **루프(반복문)**이나 복잡한 흐름 제어가 없습니다.
- 이유: 만약 무한 루프 같은 걸 쓸 수 있다면, 악의적 코드(예: 트랜잭션에 ‘로직 폭탄’)가 네트워크에 퍼져 **노드들을 멈추게 하거나 DoS 공격**을 할 수 있어요.
- 따라서 스크립트는 **간단한 계산·검증만** 할 수 있게 제한되어 안전성을 높입니다.

### (b) Stateless Verification (상태 비의존적 검증)

- 스크립트는 **검증 시 외부 상태(예: 계정DB 등)에 의존하지 않습니다**.
    
    즉, 같은 트랜잭션·같은 스크립트를 어떤 노드에서든 실행하면 **항상 같은 결과**를 얻습니다.
    
- 이 덕분에 어느 노드가 트랜잭션을 “유효”로 판단하면 다른 노드들도 동일하게 판단할 수 있어요 → **합의 가능**.

---

## 4) 실제 예시: 가장 흔한 P2PKH (전통 주소 방식)

### 잠금 스크립트 (scriptPubKey) — 출력에 저장

```
OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

```

- 의미(간단히): “제시된 퍼블릭키를 해시했을 때 와 같고, 그 퍼블릭키로 만든 서명이 유효하면 허용”

### 잠금 해제 스크립트 (scriptSig) — 입력에 제출

```
<signature> <publicKey>

```

- 실행 흐름: 먼저 scriptSig(서명, 퍼블릭키)를 스택에 넣고, 그 뒤에 scriptPubKey를 실행 → 최종적으로 검증되면 성공.

즉 실제로는 **‘서명(signature)으로 이 퍼블릭키가 가진 권한을 증명’**하는 구조입니다.

---

스크립트 실행 스택 - 비트코인의 스크립트 언어는 스택 기반 언어라고 불리며, 스택이라는 데이터 구조를 사용하기 때문입니다. 스택 데이터 구조는 '후입선출(LIFO)' 큐라고도 불립니다.

---

공개 키 해시 지불(Pay-to-Public-Key-Hash, P2PKH) ▪ 비트코인 네트워크에서 처리되는 대부분의 거래는 Pay-to-Public-Key-Hash 또는 “P2PKH” 스크립트로 잠긴 출력을 사용합니다 ▪ 이러한 출력은 출력을 공개 키 해시에 잠그는 잠금 스크립트를 포함하며, 이는 일반적으로 비트코인 주소로 알려져 있습니다 ▪ P2PKH 스크립트로 잠긴 출력은 해당 개인 키로 생성된 디지털 서명과 공개 키를 제시하면 잠금 해제(사용)할 수 있습니다(138쪽의 '디지털 서명(ECDSA)' 참조)

---

디지털 서명(ECDSA) ▪ 이 섹션에서는 디지털 서명이 어떻게 작동하는지와 개인 키를 공개하지 않고도 개인 키 소유권을 증명할 수 있는 방법을 살펴봅니다 ▪ ECDSA는 스크립트 함수 OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY에서 사용됩니다

디지털 서명(ECDSA) ▪ 디지털 서명은 비트코인에서 세 가지 목적을 수행합니다. - 첫째, 서명은 자금의 소유자임을 암시적으로 나타내는 개인 키의 소유자가 해당 자금 사용을 승인했음을 증명합니다. 승인 증명은 부인할 수 없습니다(부인방지). - 둘째, 서명은 거래(또는 거래의 특정 부분)가 서명된 후 누구에 의해서도 수정될 수 없음을 증명합니다. ▪ 각 거래 입력과 그 안에 포함될 수 있는 서명은 다른 입력이나 서명과 완전히 독립적입니다.

디지털 서명이 작동하는 방식 ▪ 디지털 서명은 두 부분으로 구성된 수학적 체계입니다. 첫 번째 부분은 메시지(거래)로부터 개인 키(서명 키)를 사용하여 서명을 생성하는 알고리즘입니다. 두 번째 부분은 메시지와 공개 키가 주어졌을 때 누구나 서명을 검증할 수 있는 알고리즘입니다.

디지털 서명의 작동 원리 ▪ 디지털 서명 생성 - 서명되는 '메시지'는 거래이거나, 더 정확히 말하면 거래 데이터의 특정 하위 집합의 해시입니다. - 서명 키는 사용자의 개인 키입니다.

디지털 서명의 작동 방식 ▪ Fsig는 일반적으로 R과 S라고 불리는 두 값으로 구성된 서명 Sig를 생성합니다 ▪ Sig = (R, S) ▪ 이제 두 값 R과 S가 계산되었으므로, 국제 표준 인코딩 방식인 구분 인코딩 규칙( Distinguished Encoding Rules, DE)을 사용하여 바이트 스트림으로 직렬화됩니다

---

이 내용은 **비트코인 거래에서 서명이 실제로 수학적으로 어떻게 만들어지는지**를 설명하는 부분이에요.

말로만 “프라이빗키로 서명한다”라고 배웠던 걸, 이제 **수식으로 표현**한 거예요.

---

## 🧩 전체 그림: 디지털 서명이란?

디지털 서명은 두 단계로 이루어집니다.

1. **서명(Signing)**:
    
    → 내가 **프라이빗키**를 사용해 특정 **메시지(거래)**에 **서명을 생성**
    
2. **검증(Verification)**:
    
    → 다른 사람이 내 **퍼블릭키**를 사용해 “이 서명이 진짜 내가 한 것인지” 검증
    

---

## ⚙️ 수식 해석

```
Sig = F_sig( F_hash(m), dA )

```

이 수식은 서명을 만드는 과정을 수학적으로 표현한 것입니다.

| 기호 | 뜻 | 쉽게 설명 |
| --- | --- | --- |
| **m** | 메시지 | 서명할 대상. 즉, 거래(transaction)의 일부 또는 전체 데이터 |
| **F_hash(m)** | 해시 함수 | 거래 내용을 짧고 고정된 길이의 **고유한 요약값(hash)** 으로 만듭니다. (예: SHA-256) |
| **dA** | 서명 키 (private key) | 사용자의 비밀 키. 오직 본인만 알고 있는 값 |
| **F_sig** | 서명 알고리즘 | 해시값과 프라이빗키를 입력으로 받아 **서명(Sig)** 을 생성하는 알고리즘 (비트코인은 ECDSA 사용) |
| **Sig** | 서명 결과 | 최종 생성된 디지털 서명값. 나중에 검증에 사용됨 |

---

## 🔍 1단계: 해시하기 (F_hash)

비트코인은 거래 전체를 서명하지 않고,

거래의 특정 부분만 뽑아서 해시를 합니다. (예: 내가 보낸 Input, Output 등)

```
hash = F_hash(m)

```

- SHA-256을 **두 번(SHA-256d)** 적용하는 것이 일반적입니다.
- 결과: 거래 내용이 조금이라도 바뀌면 완전히 다른 해시가 나옴 → **위조 방지**

---

## ✍️ 2단계: 서명 만들기 (F_sig)

이제 해시 결과를 **내 프라이빗키(dA)**로 서명합니다.

```
Sig = F_sig(hash, dA)

```

- 여기서 **F_sig**는 비트코인에서 **ECDSA (Elliptic Curve Digital Signature Algorithm)** 알고리즘이에요.
- 결과는 `(R, S)`라는 두 개의 숫자 쌍으로 구성됩니다.

즉,

```
Sig = (R, S)

```

이 두 값이 바로 내가 만든 디지털 서명입니다.

---

## 💡 직렬화(Encoding)

`(R, S)`는 단순한 두 숫자이기 때문에,

비트코인 네트워크에 전송하려면 표준 형식으로 바이트 배열화해야 합니다.

그때 쓰는 것이 **DER (Distinguished Encoding Rules)** 인코딩이에요.

그래서 실제 트랜잭션 안에는 이렇게 들어갑니다 👇

```
3044...0220R...0220S...(01)

```

(맨 뒤의 01은 “서명된 데이터가 어떤 방식으로 해시되었는지”를 표시하는 SIGHASH 플래그)

---

## ✅ 3단계: 검증 과정 (참고로 이해하기 쉽게)

누군가(노드)가 내 서명을 검증할 때는 다음 과정을 합니다.

1. 거래의 동일한 부분을 해시함 → `hash = F_hash(m)`
2. 내 **퍼블릭키(P)**와 서명값 `(R, S)`를 사용해 검증 알고리즘 실행
3. 결과가 일치하면 → “이건 프라이빗키 소유자가 만든 서명이다” ✅

즉, 프라이빗키는 네트워크에 **절대 노출되지 않고**,

퍼블릭키로도 역산이 불가능하지만,

“이 서명이 진짜 맞는지”는 누구나 검증할 수 있게 돼요.

---

## 🧠 요약 정리

| 개념 | 설명 |
| --- | --- |
| **dA** | 나의 프라이빗키 |
| **m** | 서명할 거래 데이터 |
| **F_hash** | 거래 데이터를 해시로 요약 (SHA-256 등) |
| **F_sig** | 해시 + 프라이빗키 → 서명 생성 (ECDSA) |
| **Sig** | 결과 서명 (두 수 R, S) |
| **DER 인코딩** | 서명을 바이트 형태로 표현하는 국제 표준 방식 |
| **검증 과정** | 해시 + 퍼블릭키로 서명의 유효성 확인 |

---

서명 검증 ▪ 서명을 검증하려면 서명(R과 S), 직렬화된 거래, 그리고 서명을 생성하는 데 사용된 개인 키에 대응하는 공개 키가 필요합니다. 본질적으로 서명 검증은 “이 공개 키를 생성한 개인 키의 소유자만이 이 거래에 대한 이 서명을 만들 수 있다”는 의미입니다. ▪ 서명 검증 알고리즘은 메시지(거래의 해시 또는 그 일부), 서명자의 공개 키, 그리고 서명(R과 S 값)을 입력으로 받아, 이 서명이 해당 메시지와 공개 키에 대해 유효하면 TRUE를 반환합니다.

서명 검증 ▪ 여러 입력을 포함하는 거래는 각 입력에서 거래의 다른 부분을 커밋하는 서로 다른 SIGHASH 플래그를 가진 서명을 가질 수 있습니다 ▪ 비트코인 거래에는 서로 다른 “소유자”의 입력이 포함될 수 있으며, 이들은 부분적으로 구성된(유효하지 않은) 거래에서 오직 하나의 입력만 서명하고, 다른 사람들과 협력하여 유효한 거래를 만들기 위해 필요한 모든 서명을 수집할 수 있습니다.

---

핵심은 **“검증에 필요한 것들”**과 **“여러 입력(=여러 소유자)이 있을 때 서명이 어떻게 동작하는지”** 입니다.

---

## 1) 서명 검증에 필요한 것 (한 문장 요약)

> 검증자(노드)는
> 
> 
> `서명(R,S)` + `거래(또는 거래의 일부를 해시한 값)` + `서명자의 공개키`
> 
> 이 세 가지를 받아서 “이 공개키의 주인만이 이 서명을 만들 수 있다”를 확인합니다.
> 

쉽게 말하면:

- 메시지(거래 내용)를 똑같이 해시해서,
- 공개키와 서명을 가지고 수학적 검증을 돌려서,
- “검증 결과가 TRUE면” → 서명이 맞음, “FALSE면” → 위조 또는 변조된 것.

---

## 2) SIGHASH 플래그(=서명이 커밋하는 거래의 범위)

여기서 중요한 트윗: **서명은 ‘거래 전체’를 항상 묶는 게 아니라, 경우에 따라 ‘거래의 일부’만 묶을 수 있다**는 점입니다.

이 동작을 제어하는 것이 **SIGHASH 플래그**입니다.

대표적인 플래그(개념만):

- **SIGHASH_ALL**: 이 서명은 “거래 전체(모든 입력과 출력)를” 묶음
    
    → 가장 안전: 다른 사람이 거래를 바꿀 수 없음
    
- **SIGHASH_NONE**: 이 서명은 “출력(받는 사람 등)은 묶지 않음”
    
    → 서명자는 입력을 고정하지만, 누군가가 출력을 바꿀 수 있음
    
- **SIGHASH_SINGLE**: 이 서명은 “자기 입력과 동일 인덱스의 출력만” 묶음

(세부 규칙은 더 있지만, 핵심은 “어떤 부분을 서명에 포함시키느냐”를 정한다는 것)

---

## 4) 여러 입력(여러 소유자)이 들어가는 거래 — 부분 서명과 협업

한 거래에 입력이 여러 개 있으면(각 입력은 서로 다른 UTXO, 즉 서로 다른 소유자 소유일 수 있음)

각 입력의 **소유자(UTXO 주인)** 는 **자기 입력 부분에 대해서만 서명**하면 됩니다. 즉:

- 거래 초안: 누군가(혹은 여러 사람)가 “이런 거래를 만들겠다”라고 뼈대를 만든다.
- 각 입력의 소유자는 **자기 입력을 쓸 권리**만 증명하면 되므로,
    
    **다른 사람의 입력이나 출력**을 바꾸지 않는 한 **자기 입력만 서명**할 수 있음.
    
- 이렇게 모아서(=여러 서명을 모아) 최종적으로 모든 필요한 서명이 붙으면 **완성된 유효한 거래**가 됩니다.

이 방식 덕분에:

- **협업 전송**(예: 누군가의 여러 입력을 한 거래로 묶어 수수료 절감) 이 가능하고,
- **코인조인(CoinJoin)** 같은 프라이버시 기법이나,
- **다중 서명(multi-sig)** 절차도 가능해집니다.

---

## 5) 간단한 예시 (그림으로 생각)

1. 거래 초안(두 입력, 두 소유자 A와 B, 하나의 출력):

```
Inputs: [A의 UTXO], [B의 UTXO]
Outputs: [수신자 C에게 1 BTC], [잔돈들...]

```

1. A는 자신의 입력에 대해 서명(예: SIGHASH_ALL을 사용하면 거래 전체를 묶으므로 다른 사람이 마음대로 변경하면 안 됨).
2. B도 자신의 입력에 대해 서명.
3. 서명 둘 다 모이면 노드가 각각의 서명을 검증 → 모두 유효하면 거래 유효.

중요: **A가 서명할 때 어떤 SIGHASH를 썼느냐에 따라**

다른 사람이 출력이나 다른 입력을 바꿀 수 있는지/없는지가 달라집니다.

---

## 6) 실무에서의 의미 (요약)

- **검증**: 누구나 공개키·서명·거래(또는 해시된 일부)를 가지고 TRUE/FALSE로 검증 가능.
- **부분 서명**: 거래는 여러 사람이 부분적으로 서명해서 완성할 수 있음 — 협업 가능.
- **SIGHASH**: 서명이 “거래의 어느 부분을 확정(커밋)하느냐”를 결정.
    
    → 이걸로 “내 서명이 붙은 상태에서 누가 무얼 바꿀 수 있는지” 제어함.
    

---

서명 해시 유형(SIGHASH) ▪ ANYONECANPAY가 설정되면 하나의 입력만 서명되고 나머지 입력(및 그 순서 번호)은 수정할 수 있도록 열려 있습니다 ▪ ANYONECANPAY 값은 0x80입니다

---

서명 해시 타입(SIGHASH) ▪ ALL|ANYONECANPAY 이 구조는 '크라우드펀딩' 스타일의 트랜잭션을 만드는 데 사용할 수 있습니다. 자금을 모으려는 사람은 단일 출력으로 트랜잭션을 구성할 수 있습니다. 단일 출력은 모금자에게 '목표' 금액을 지급합니다. 이러한 트랜잭션은 입력이 없기 때문에 명백히 유효하지 않습니다. 그러나 다른 사람들이 자신의 입력을 추가하여 기부할 수 있습니다. 그들은 자신의 입력에 대해 ALL|ANYONECANPAY로 서명합니다. 출력 금액에 도달할 만큼 충분한 입력이 모이지 않으면 트랜잭션은 유효하지 않습니다. 각 기부는 '약속'으로, 전체 목표 금액이 모일 때까지 모금자가 수령할 수 없습니다.

서명 해시 타입(SIGHASH) ▪ NONE 이 구조는 특정 금액의 “보통 수표” 또는 “백지 수표”를 만드는 데 사용할 수 있습니다. 입력에 대해서는 서명하지만, 출력 잠금 스크립트는 변경할 수 있도록 허용합니다. 누구든지 자신의 비트코인 주소를 출력 잠금 스크립트에 작성하고 트랜잭션을 사용할 수 있습니다. 그러나 출력 값 자체는 서명으로 잠겨 있습니다. ▪ NONE|ANYONECANPAY 이 구조는 “먼지 수집기”를 만드는 데 사용할 수 있습니다. 지갑에 아주 작은 UTXO를 가진 사용자는 수수료 비용이 먼지 가치보다 커서 이러한 UTXO를 쉽게 사용할 수 없습니다. 이 타입의 서명을 사용하면, 먼지 UTXO를 누구나 모아서 원하는 때에 사용할 수 있도록 기부할 수 있습니다.

---

**“누가 무엇을 고정(commit)하고 누가 바꿀 수 있는지”** 관점으로 아주 직관적으로 풀어드릴게요.

---

## 먼저 — SIGHASH의 기본 아이디어(간단)

서명에는 **어떤 부분(Inputs / Outputs / 일부 인덱스)을 서명으로 묶을지**를 결정하는 “타입”이 붙습니다.

두 축이 있어요:

- **ALL / NONE / SINGLE** — 서명이 **출력(outputs)** 중 어느 부분을 묶는가를 결정
    - **ALL**: 모든 출력(들)을 묶는다 → 누군가 출력(누가 받고 얼마를 받는지)을 바꿀 수 없음
    - **NONE**: 출력들을 전혀 묶지 않는다 → 출력(누가 받을지)은 누군가가 바꿀 수 있음
    - **SINGLE**: 자신의 입력과 **같은 인덱스의 출력** 하나만 묶음
- **ANYONECANPAY (플래그)** — 이 옵션을 추가하면 **서명자가 자신의 입력만** 묶는다(=다른 입력은 서명에 포함되지 않음).
    
    → 즉, 다른 사람이 **자기 입력을 자유롭게 추가**할 수 있게 해줌.
    

이 둘을 조합해서 (예: `ALL|ANYONECANPAY`, `NONE`, `NONE|ANYONECANPAY`) 다양한 협업/특수한 동작을 만들 수 있습니다.

---

## 1) `ALL | ANYONECANPAY` — 크라우드펀딩(모금) 스타일

### 핵심(한 문장)

- **출력(모금 목표, 즉 “수령자와 지급 액수”)은 모두 고정**되지만, **누구나 자신의 입력(기부금)을 추가**할 수 있다.

### 동작 방식(단계)

1. 모금 주최자가 **목표 금액을 자신에게 지급하는 단일 출력**을 가진 미완성 트랜잭션(아직 입력 없음)을 만든다. (이 상태는 유효하지 않음 — 입력이 없으니까)
2. 기부자는 각자 자신의 **UTXO(자기 돈)를 이 트랜잭션에 입력으로 추가**하고, **`ALL|ANYONECANPAY`*로 서명한다.
    - `ANYONECANPAY` 때문에 기부자는 “내 입력만” 서명한다 → 다른 사람의 입력 추가는 허용
    - `ALL` 때문에 기부자는 “출력(모금자와 목표액)”이 고정되는 것에 동의한다 → 출력 변경 불가
3. 여러 기부자가 입력을 추가해서 총액이 목표에 도달하면 트랜잭션은 유효해지고 모금자가 수령 가능.

### 직관적 의미

- 기부자들은 “나는 이 목표(수령자+금액)에 돈을 보태겠다”는 **약속(서명)**만 하는 셈.
- 충분한 기부(입력)가 모여 목표액을 만족하면 모금자는 그 돈을 실제로 받을 수 있음.

---

## 2) `NONE` — “백지(혹은 일반 수표)” 스타일

### 핵심(한 문장)

- 서명자는 **자신의 입력(및 보통은 다른 입력들도)**에 대해 서명하지만, **출력들은 전혀 묶지 않는다** → 누군가가 출력(누가 받을지, 어느 주소로 보낼지)을 바꿀 수 있다.

### 용도(예: 백지 수표)

- 누군가가 “이 입력(내 돈)을 제공하겠다”는 걸 증명하는 서명을 만들면, 다른 사람이 그 서명을 이용해 **출력을 원하는 대로 채워넣어(누구에게 얼마를 줄지 정해)** 최종 거래를 완성할 수 있음.
- 이걸 **“백지 수표”**로 비유하면: 서명자는 금액(입력에서 나오는 금액)을 제공하겠다고 약속만 하고, 수취인은 나중에 수표 뒷면에 수취인 이름(출력)을 적어 거래를 완성할 수 있음.

### 주의

- 출력이 변경 가능하므로 악용 위험이 있으니, 실제 사용 시 매우 신중해야 합니다.

---

## 3) `NONE | ANYONECANPAY` — “먼지 수집기(dust collector)” 스타일

### 핵심(한 문장)

- **각 기여자는 자신의 작은 UTXO(먼지)를 단독으로 서명해 제출**하고, 이 서명은 출력에 관해 아무 것도 약속하지 않는다. 결과적으로 누군가가 이 많은 작은 입력들을 모아(집합) 큰 거래(수수료를 합리화하는 거래)를 만들 수 있다.

### 왜 이게 유용한가?

- 개인이 가진 아주 작은 UTXO(예: 너무 작은 금액)는 직접 쓰려고 하면 **수수료가 더 비싸서** 사실상 사용 불가(‘먼지’라 불림).
- `NONE|ANYONECANPAY`로 서명하면:
    - 기부자(먼지 보유자)는 자신의 입력만 서명(ANYONECANPAY) → 다른 사람은 추가 입력을 더할 수 있음.
    - 또한 `NONE`이므로 출력을 고정하지 않음 → 모아진 먼지들을 누군가가 모아 하나의 출력(예: 합쳐서 누구에게 보내기)에 쓸 수 있음.
- 즉, 많은 먼지를 **모아(집산) 사용 가능**하게 만드는 패턴입니다.

---

## 보안적·실무적 주의사항 (중요)

- 이런 SIGHASH 트릭은 **강력하지만 위험**합니다. 특히 `NONE`처럼 출력을 묶지 않으면 **누군가가 의도와 다르게 출력(수취인)을 바꿀 수 있음**.
- 따라서 실제 사용에서는 **명확한 프로토콜(규칙)**과 **신뢰 가능한 툴/지갑**을 사용해야 하며, 잘못된 서명 타입 사용은 자금 손실로 이어질 수 있습니다.
- 크라우드펀딩 같은 경우도, 참여자들은 “내 돈이 이 목표에만 쓰인다”는 걸 확실히 이해하고 서명해야 합니다.

---

## 한눈 정리 (표식으로)

| SIGHASH 타입 | 무엇을 묶나(Outputs) | 누구의 입력을 묶나 | 활용 |
| --- | --- | --- | --- |
| `ALL` | 모든 출력 고정 | 서명한 입력 포함(기본) | 일반적인 거래 (안전) |
| `ALL | ANYONECANPAY` | 모든 출력 고정 | **오직 자신의 입력만** |
| `NONE` | 출력 전혀 고정하지 않음 | 보통 모든 입력 서명(=입력 소유권 고정) | “백지 수표” 스타일(출력은 나중에 채움) |
| `NONE | ANYONECANPAY` | 출력 전혀 고정 | 오직 자신의 입력만 |

---





공개 키 해시 지불(Pay-to-Public-Key-Hash, P2PKH) ▪ 비트코인 네트워크에서 처리되는 대부분의 거래는 Pay-to-Public-Key-Hash 또는 “P2PKH” 스크립트로 잠긴 출력을 사용합니다 ▪ 이러한 출력은 출력을 공개 키 해시에 잠그는 잠금 스크립트를 포함하며, 이는 일반적으로 비트코인 주소로 알려져 있습니다 ▪ P2PKH 스크립트로 잠긴 출력은 해당 개인 키로 생성된 디지털 서명과 공개 키를 제시하면 잠금 해제(사용)할 수 있습니다(138쪽의 '디지털 서명(ECDSA)' 참조)

---

디지털 서명(ECDSA) ▪ 이 섹션에서는 디지털 서명이 어떻게 작동하는지와 개인 키를 공개하지 않고도 개인 키 소유권을 증명할 수 있는 방법을 살펴봅니다 ▪ ECDSA는 스크립트 함수 OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY에서 사용됩니다

디지털 서명(ECDSA) ▪ 디지털 서명은 비트코인에서 세 가지 목적을 수행합니다. - 첫째, 서명은 자금의 소유자임을 암시적으로 나타내는 개인 키의 소유자가 해당 자금 사용을 승인했음을 증명합니다. 승인 증명은 부인할 수 없습니다(부인방지). - 둘째, 서명은 거래(또는 거래의 특정 부분)가 서명된 후 누구에 의해서도 수정될 수 없음을 증명합니다. ▪ 각 거래 입력과 그 안에 포함될 수 있는 서명은 다른 입력이나 서명과 완전히 독립적입니다.

디지털 서명이 작동하는 방식 ▪ 디지털 서명은 두 부분으로 구성된 수학적 체계입니다. 첫 번째 부분은 메시지(거래)로부터 개인 키(서명 키)를 사용하여 서명을 생성하는 알고리즘입니다. 두 번째 부분은 메시지와 공개 키가 주어졌을 때 누구나 서명을 검증할 수 있는 알고리즘입니다.

디지털 서명의 작동 원리 ▪ 디지털 서명 생성 - 서명되는 '메시지'는 거래이거나, 더 정확히 말하면 거래 데이터의 특정 하위 집합의 해시입니다. - 서명 키는 사용자의 개인 키입니다.

디지털 서명의 작동 방식 ▪ Fsig는 일반적으로 R과 S라고 불리는 두 값으로 구성된 서명 Sig를 생성합니다 ▪ Sig = (R, S) ▪ 이제 두 값 R과 S가 계산되었으므로, 국제 표준 인코딩 방식인 구분 인코딩 규칙( Distinguished Encoding Rules, DE)을 사용하여 바이트 스트림으로 직렬화됩니다

---

이 내용은 **비트코인 거래에서 서명이 실제로 수학적으로 어떻게 만들어지는지**를 설명하는 부분이에요.

말로만 “프라이빗키로 서명한다”라고 배웠던 걸, 이제 **수식으로 표현**한 거예요.

---

## 🧩 전체 그림: 디지털 서명이란?

디지털 서명은 두 단계로 이루어집니다.

1. **서명(Signing)**:
    
    → 내가 **프라이빗키**를 사용해 특정 **메시지(거래)**에 **서명을 생성**
    
2. **검증(Verification)**:
    
    → 다른 사람이 내 **퍼블릭키**를 사용해 “이 서명이 진짜 내가 한 것인지” 검증
    

---

## ⚙️ 수식 해석

```
Sig = F_sig( F_hash(m), dA )

```

이 수식은 서명을 만드는 과정을 수학적으로 표현한 것입니다.

| 기호 | 뜻 | 쉽게 설명 |
| --- | --- | --- |
| **m** | 메시지 | 서명할 대상. 즉, 거래(transaction)의 일부 또는 전체 데이터 |
| **F_hash(m)** | 해시 함수 | 거래 내용을 짧고 고정된 길이의 **고유한 요약값(hash)** 으로 만듭니다. (예: SHA-256) |
| **dA** | 서명 키 (private key) | 사용자의 비밀 키. 오직 본인만 알고 있는 값 |
| **F_sig** | 서명 알고리즘 | 해시값과 프라이빗키를 입력으로 받아 **서명(Sig)** 을 생성하는 알고리즘 (비트코인은 ECDSA 사용) |
| **Sig** | 서명 결과 | 최종 생성된 디지털 서명값. 나중에 검증에 사용됨 |

---

## 🔍 1단계: 해시하기 (F_hash)

비트코인은 거래 전체를 서명하지 않고,

거래의 특정 부분만 뽑아서 해시를 합니다. (예: 내가 보낸 Input, Output 등)

```
hash = F_hash(m)

```

- SHA-256을 **두 번(SHA-256d)** 적용하는 것이 일반적입니다.
- 결과: 거래 내용이 조금이라도 바뀌면 완전히 다른 해시가 나옴 → **위조 방지**

---

## ✍️ 2단계: 서명 만들기 (F_sig)

이제 해시 결과를 **내 프라이빗키(dA)**로 서명합니다.

```
Sig = F_sig(hash, dA)

```

- 여기서 **F_sig**는 비트코인에서 **ECDSA (Elliptic Curve Digital Signature Algorithm)** 알고리즘이에요.
- 결과는 `(R, S)`라는 두 개의 숫자 쌍으로 구성됩니다.

즉,

```
Sig = (R, S)

```

이 두 값이 바로 내가 만든 디지털 서명입니다.

---

## 💡 직렬화(Encoding)

`(R, S)`는 단순한 두 숫자이기 때문에,

비트코인 네트워크에 전송하려면 표준 형식으로 바이트 배열화해야 합니다.

그때 쓰는 것이 **DER (Distinguished Encoding Rules)** 인코딩이에요.

그래서 실제 트랜잭션 안에는 이렇게 들어갑니다 👇

```
3044...0220R...0220S...(01)

```

(맨 뒤의 01은 “서명된 데이터가 어떤 방식으로 해시되었는지”를 표시하는 SIGHASH 플래그)

---

## ✅ 3단계: 검증 과정 (참고로 이해하기 쉽게)

누군가(노드)가 내 서명을 검증할 때는 다음 과정을 합니다.

1. 거래의 동일한 부분을 해시함 → `hash = F_hash(m)`
2. 내 **퍼블릭키(P)**와 서명값 `(R, S)`를 사용해 검증 알고리즘 실행
3. 결과가 일치하면 → “이건 프라이빗키 소유자가 만든 서명이다” ✅

즉, 프라이빗키는 네트워크에 **절대 노출되지 않고**,

퍼블릭키로도 역산이 불가능하지만,

“이 서명이 진짜 맞는지”는 누구나 검증할 수 있게 돼요.

---

## 🧠 요약 정리

| 개념 | 설명 |
| --- | --- |
| **dA** | 나의 프라이빗키 |
| **m** | 서명할 거래 데이터 |
| **F_hash** | 거래 데이터를 해시로 요약 (SHA-256 등) |
| **F_sig** | 해시 + 프라이빗키 → 서명 생성 (ECDSA) |
| **Sig** | 결과 서명 (두 수 R, S) |
| **DER 인코딩** | 서명을 바이트 형태로 표현하는 국제 표준 방식 |
| **검증 과정** | 해시 + 퍼블릭키로 서명의 유효성 확인 |

---

서명 검증 ▪ 서명을 검증하려면 서명(R과 S), 직렬화된 거래, 그리고 서명을 생성하는 데 사용된 개인 키에 대응하는 공개 키가 필요합니다. 본질적으로 서명 검증은 “이 공개 키를 생성한 개인 키의 소유자만이 이 거래에 대한 이 서명을 만들 수 있다”는 의미입니다. ▪ 서명 검증 알고리즘은 메시지(거래의 해시 또는 그 일부), 서명자의 공개 키, 그리고 서명(R과 S 값)을 입력으로 받아, 이 서명이 해당 메시지와 공개 키에 대해 유효하면 TRUE를 반환합니다.

서명 검증 ▪ 여러 입력을 포함하는 거래는 각 입력에서 거래의 다른 부분을 커밋하는 서로 다른 SIGHASH 플래그를 가진 서명을 가질 수 있습니다 ▪ 비트코인 거래에는 서로 다른 “소유자”의 입력이 포함될 수 있으며, 이들은 부분적으로 구성된(유효하지 않은) 거래에서 오직 하나의 입력만 서명하고, 다른 사람들과 협력하여 유효한 거래를 만들기 위해 필요한 모든 서명을 수집할 수 있습니다.

---

핵심은 **“검증에 필요한 것들”**과 **“여러 입력(=여러 소유자)이 있을 때 서명이 어떻게 동작하는지”** 입니다.

---

## 1) 서명 검증에 필요한 것 (한 문장 요약)

> 검증자(노드)는
> 
> 
> `서명(R,S)` + `거래(또는 거래의 일부를 해시한 값)` + `서명자의 공개키`
> 
> 이 세 가지를 받아서 “이 공개키의 주인만이 이 서명을 만들 수 있다”를 확인합니다.
> 

쉽게 말하면:

- 메시지(거래 내용)를 똑같이 해시해서,
- 공개키와 서명을 가지고 수학적 검증을 돌려서,
- “검증 결과가 TRUE면” → 서명이 맞음, “FALSE면” → 위조 또는 변조된 것.

---

## 2) SIGHASH 플래그(=서명이 커밋하는 거래의 범위)

여기서 중요한 트윗: **서명은 ‘거래 전체’를 항상 묶는 게 아니라, 경우에 따라 ‘거래의 일부’만 묶을 수 있다**는 점입니다.

이 동작을 제어하는 것이 **SIGHASH 플래그**입니다.

대표적인 플래그(개념만):

- **SIGHASH_ALL**: 이 서명은 “거래 전체(모든 입력과 출력)를” 묶음
    
    → 가장 안전: 다른 사람이 거래를 바꿀 수 없음
    
- **SIGHASH_NONE**: 이 서명은 “출력(받는 사람 등)은 묶지 않음”
    
    → 서명자는 입력을 고정하지만, 누군가가 출력을 바꿀 수 있음
    
- **SIGHASH_SINGLE**: 이 서명은 “자기 입력과 동일 인덱스의 출력만” 묶음

(세부 규칙은 더 있지만, 핵심은 “어떤 부분을 서명에 포함시키느냐”를 정한다는 것)

### Q. 위의 강의자료 내용에서 거래 일부만 사용하면 ‘꼭 필수적으로 포함되어야 하는 부분’은 어떤 부분인가요? 그리고, 그 이유가 무엇인가요? 저는 지금 거래에 사용되는 부분(지금 사용하려는 UTXO 하나)만 있으면 충분하다고 생각하는데, 맞나요?

지금 질문은 “비트코인에서 **서명할 때, 어떤 부분을 반드시 포함해야 하는가**” — 즉

**“서명이 유효하려면 거래의 어떤 데이터까지 포함해야 하는가?”** 에 관한 것입니다.

당신이 말한 “지금 사용하려는 UTXO 하나(=Input 하나)”만 서명하면 충분하지 않을까 하는 의문은 자연스러워요.

하지만 실제로는 그보다 **조금 더 많은 부분을 반드시 포함해야** 합니다.

이유를 단계적으로 살펴볼게요 👇

---

## 🧩 1️⃣ 먼저, 서명의 목적은 “내가 **어떤 코인을 누구에게 주겠다는 것**을 확실히 증명하는 것”이에요

즉, **서명은 두 가지를 동시에 약속해야** 합니다:

1. **내가 실제로 이 UTXO의 소유자임을 증명** (내 입력이 유효함)
2. **이 UTXO가 어떤 거래(출력)에 쓰이는지를 명확히 한정** (거래 변조 방지)

그래서 서명에는 단순히 “내 입력” 정보만이 아니라,

“이 입력이 포함된 거래의 구조적 맥락”까지 포함되어야 합니다.

---

## ⚙️ 2️⃣ 서명은 “거래 전체(Tx)의 요약(hash)”에 대해 만들어짐

서명할 때는 이 과정을 거칩니다.

```
해시 = SHA256(SHA256(거래 데이터 + SIGHASH flag))
서명 = Sign(해시, 내 Private Key)

```

즉, 서명은 **“거래 데이터의 해시값”**을 기준으로 만들어집니다.

그런데 “거래 데이터”를 구성할 때, SIGHASH 플래그에 따라 **어떤 부분을 포함할지**가 결정됩니다.

---

## 💡 3️⃣ 어떤 경우에도 반드시 포함되어야 하는 최소 데이터

SIGHASH가 무엇이든 간에,

**“현재 이 입력이 어떤 코인(UTXO)을 쓰고 있는지”**는 반드시 포함되어야 합니다.

즉, 다음 정보는 항상 서명에 들어갑니다 👇

| 필드 | 설명 | 이유 |
| --- | --- | --- |
| **Input의 참조 정보** (`prev_txid`, `vout index`) | 어떤 이전 출력(UTXO)을 쓰는가 | 서명자가 실제로 소유한 코인임을 증명하기 위해 필요 |
| **해당 Input의 ScriptCode** | 즉, 잠금 스크립트(scriptPubKey)의 핵심 부분 | 퍼블릭키 해시 검증 등 ‘소유권 조건’을 반영하기 위해 필요 |
| **금액(value)** | 해당 UTXO의 금액 | 서명된 해시가 금액을 포함해야 위조 방지 가능 (특히 SegWit 이후 필수) |
| **SIGHASH 플래그 값** | 어떤 범위를 서명에 포함시킬지 | 검증 시 일관성을 위해 반드시 포함 |

---

## 🧱 4️⃣ “지금 사용하려는 UTXO 하나만 서명하면 충분하지 않나요?”

→ **거의 맞지만, 완전히는 아닙니다.**

당신 말대로 “지금 사용하려는 UTXO 하나(Input 하나)”만 서명하면

**소유권 증명**은 충분해요.

즉, “이 코인을 내가 쓸 수 있는 권리가 있다”는 건 증명됩니다.

하지만 그 서명만으로는 **“이 코인이 어디로 가는지(누가 받는지)”**는 확실하지 않아요.

→ 그러면 나중에 누군가가 출력(Output)을 바꿔서

“내가 서명한 입력을 엉뚱한 주소로 보내는 거래”를 만들 수도 있죠.

그래서 보통은 최소한 **내 입력이 포함된 거래의 구조(즉, 출력을 포함한 전체 형태)** 까지는 서명에 포함시켜야 합니다.

---

## 🔐 5️⃣ 각 SIGHASH 플래그가 보호하는 범위 (요약)

| SIGHASH 플래그 | 서명에 포함되는 부분 | 보호되는 것 |
| --- | --- | --- |
| **ALL** | 모든 입력 + 모든 출력 | 거래 전체 불변 (일반적인 경우) |
| **NONE** | 모든 입력만, 출력은 제외 | 내가 코인을 내놓을 수는 있지만 수신자는 나중에 결정 가능 |
| **SINGLE** | 내 입력 + 같은 인덱스의 출력 | 1:1 대응 관계 고정 |
| **ANYONECANPAY** | 현재 입력만 (다른 입력 제외) | 내 입력만 보호하고, 다른 입력은 자유롭게 추가 가능 |

---

## 🧩 6️⃣ 결론: “필수적으로 포함되어야 하는 부분”

| 항목 | 이유 |
| --- | --- |
| 🧾 **내 입력(UTXO)** (txid, vout index) | 내가 쓰는 코인이 무엇인지 명시해야 함 |
| 🔐 **내 소유 조건(script, value)** | 내가 진짜 주인임을 증명하기 위해 필요 |
| 📦 **(보통) 출력 정보(누가 얼마를 받는지)** | 거래 변조 방지 — 돈이 엉뚱한 곳으로 가는 걸 막음 |
| ⚙️ **SIGHASH flag 값** | 검증 시 어떤 범위를 고정할지 일관성 확보 |

> ✅ 즉, 서명할 때 “내 입력만”은 기본적으로 포함되지만,
> 
> 
> 안전을 위해 **내 입력이 연결된 거래의 구조(특히 출력)** 까지 해시해야
> 
> “내 돈이 다른 곳으로 변조되는 걸 막을 수 있습니다.”
> 

---

## 🎯 요약 한 문장

> 비트코인 서명은 “이 입력이 어떤 거래(출력 구조)에 포함되어 있는가”를 함께 서명해야 안전합니다.
> 
> 
> **입력만 포함하면 ‘내 소유’는 증명되지만, ‘누구에게 보낸다’는 건 보장되지 않아요.**
> 

### Q. 공동결제·교환(atomic swap)과 SIGHASH_SINGLE의 예시 거래를 하나만 더 보여주세요

이번엔 **SIGHASH_SINGLE이 실제로 왜 필요한지**,

즉 “서로 다른 두 사람이 **하나의 거래(transaction)** 에 함께 참여하지만

각자 자기 입력·출력만 확정하는 상황”을 예시로 보여드릴게요.

---

## 🧩 시나리오: Alice와 Bob이 **서로 다른 코인**을 교환 (Atomic Swap)

- Alice는 0.5 BTC를 가지고 있고, Bob은 20 LTC(라이트코인)를 가지고 있음.
- 두 사람은 **서로 신뢰하지 않아도 교환이 자동으로 완료되거나 전부 취소되는** 구조를 원함.
- 여기서는 개념 설명용으로 **“하나의 비트코인 거래 안에서의 협력형 결제”**만 보죠.

---

## 💰 거래 구조 (단순화 예시)

| 입력 (Inputs) | 금액 | 소유자 | 설명 |
| --- | --- | --- | --- |
| Input 0 | 0.5 BTC | **Alice** | Alice의 UTXO |
| Input 1 | 0.5 BTC | **Bob** | Bob의 UTXO |

| 출력 (Outputs) | 금액 | 수신자 | 설명 |
| --- | --- | --- | --- |
| Output 0 | 0.5 BTC | **Bob의 주소** | Bob이 받을 코인 (Alice → Bob) |
| Output 1 | 0.5 BTC | **Alice의 주소** | Alice가 받을 코인 (Bob → Alice) |

즉, **서로 코인을 맞교환**하는 거래입니다 👇

```
[Input 0: Alice의 코인 0.5 BTC] ──▶ [Output 0: Bob에게 0.5 BTC]
[Input 1: Bob의 코인 0.5 BTC]   ──▶ [Output 1: Alice에게 0.5 BTC]

```

---

## 🔐 일반적인 경우 (SIGHASH_ALL)라면?

- Alice가 거래를 서명하면, **모든 출력(Output 0, Output 1)** 이 서명에 포함됨.
- Bob이 아직 Output 1(자기 것이 아님)을 바꿀 수도 있어서 Alice는 위험함.
    
    (즉, Alice는 다른 사람의 출력까지 미리 확정할 수 없음!)
    

---

## ⚙️ 그래서 사용하는 것: **SIGHASH_SINGLE**

각자 자기 입력에 해당하는 출력 **하나만** 서명으로 묶습니다.

| 서명자 | 입력 | 서명 모드 | 묶이는 출력 | 설명 |
| --- | --- | --- | --- | --- |
| **Alice** | Input 0 | `SIGHASH_SINGLE` | Output 0 | “나는 내 코인(0.5BTC)을 Bob의 주소로 보내는 것만 확정할게.” |
| **Bob** | Input 1 | `SIGHASH_SINGLE` | Output 1 | “나는 내 코인(0.5BTC)을 Alice의 주소로 보내는 것만 확정할게.” |

이때:

- Alice는 Output 0만 확정했으므로 Output 1은 관심 없음.
- Bob은 Output 1만 확정했으므로 Output 0은 관심 없음.

둘 다 **서로의 서명에 간섭하지 않고 거래 일부만 커밋**한 셈이에요.

---

## ✅ 결과

- 거래가 완성되어 두 서명이 모두 포함되면,
    
    네트워크는 전체 거래를 유효하다고 보고 블록에 포함시킵니다.
    
- 한쪽만 서명하면? → 불완전 거래 → 블록에 포함될 수 없음.
    
    따라서 “둘 다 참여해야만 실행” = Atomic(원자적) 조건 달성.
    

---

## 💡 핵심 요약

| 항목 | 의미 |
| --- | --- |
| **SIGHASH_SINGLE** | 내 입력과 같은 인덱스의 출력만 서명으로 고정 |
| **효과** | 다른 사람의 출력(결과)을 바꿀 수 없고, 자기 부분만 확정 |
| **활용 사례** | 공동 결제, 원자적 교환(Atomic Swap), 코인조인(CoinJoin) 등 협력형 트랜잭션 |

---

📘 **요약 문장으로 정리하면:**

> SIGHASH_SINGLE은 “나는 내 입력이 연결된 이 출력 하나만 책임지고 서명하겠다”는 의미예요.
> 
> 
> 여러 참여자가 한 거래에 함께 참여하되, 각자 자기 몫만 확정하는 구조(예: Atomic Swap)에 꼭 필요합니다.
> 

---

## 4) 여러 입력(여러 소유자)이 들어가는 거래 — 부분 서명과 협업

한 거래에 입력이 여러 개 있으면(각 입력은 서로 다른 UTXO, 즉 서로 다른 소유자 소유일 수 있음)

각 입력의 **소유자(UTXO 주인)** 는 **자기 입력 부분에 대해서만 서명**하면 됩니다. 즉:

- 거래 초안: 누군가(혹은 여러 사람)가 “이런 거래를 만들겠다”라고 뼈대를 만든다.
- 각 입력의 소유자는 **자기 입력을 쓸 권리**만 증명하면 되므로,
    
    **다른 사람의 입력이나 출력**을 바꾸지 않는 한 **자기 입력만 서명**할 수 있음.
    
- 이렇게 모아서(=여러 서명을 모아) 최종적으로 모든 필요한 서명이 붙으면 **완성된 유효한 거래**가 됩니다.

이 방식 덕분에:

- **협업 전송**(예: 누군가의 여러 입력을 한 거래로 묶어 수수료 절감) 이 가능하고,
- **코인조인(CoinJoin)** 같은 프라이버시 기법이나,
- **다중 서명(multi-sig)** 절차도 가능해집니다.

---

서명 해시 유형(SIGHASH) ▪ ANYONECANPAY가 설정되면 하나의 입력만 서명되고 나머지 입력(및 그 순서 번호)은 수정할 수 있도록 열려 있습니다 ▪ ANYONECANPAY 값은 0x80입니다

---

서명 해시 타입(SIGHASH) ▪ ALL|ANYONECANPAY 이 구조는 '크라우드펀딩' 스타일의 트랜잭션을 만드는 데 사용할 수 있습니다. 자금을 모으려는 사람은 단일 출력으로 트랜잭션을 구성할 수 있습니다. 단일 출력은 모금자에게 '목표' 금액을 지급합니다. 이러한 트랜잭션은 입력이 없기 때문에 명백히 유효하지 않습니다. 그러나 다른 사람들이 자신의 입력을 추가하여 기부할 수 있습니다. 그들은 자신의 입력에 대해 ALL|ANYONECANPAY로 서명합니다. 출력 금액에 도달할 만큼 충분한 입력이 모이지 않으면 트랜잭션은 유효하지 않습니다. 각 기부는 '약속'으로, 전체 목표 금액이 모일 때까지 모금자가 수령할 수 없습니다.

서명 해시 타입(SIGHASH) ▪ NONE 이 구조는 특정 금액의 “보통 수표” 또는 “백지 수표”를 만드는 데 사용할 수 있습니다. 입력에 대해서는 서명하지만, 출력 잠금 스크립트는 변경할 수 있도록 허용합니다. 누구든지 자신의 비트코인 주소를 출력 잠금 스크립트에 작성하고 트랜잭션을 사용할 수 있습니다. 그러나 출력 값 자체는 서명으로 잠겨 있습니다. ▪ NONE|ANYONECANPAY 이 구조는 “먼지 수집기”를 만드는 데 사용할 수 있습니다. 지갑에 아주 작은 UTXO를 가진 사용자는 수수료 비용이 먼지 가치보다 커서 이러한 UTXO를 쉽게 사용할 수 없습니다. 이 타입의 서명을 사용하면, 먼지 UTXO를 누구나 모아서 원하는 때에 사용할 수 있도록 기부할 수 있습니다.

---

**“누가 무엇을 고정(commit)하고 누가 바꿀 수 있는지”** 관점으로 아주 직관적으로 풀어드릴게요.

---

## 먼저 — SIGHASH의 기본 아이디어(간단)

서명에는 **어떤 부분(Inputs / Outputs / 일부 인덱스)을 서명으로 묶을지**를 결정하는 “타입”이 붙습니다.

두 축이 있어요:

- **ALL / NONE / SINGLE** — 서명이 **출력(outputs)** 중 어느 부분을 묶는가를 결정
    - **ALL**: 모든 출력(들)을 묶는다 → 누군가 출력(누가 받고 얼마를 받는지)을 바꿀 수 없음
    - **NONE**: 출력들을 전혀 묶지 않는다 → 출력(누가 받을지)은 누군가가 바꿀 수 있음
    - **SINGLE**: 자신의 입력과 **같은 인덱스의 출력** 하나만 묶음
- **ANYONECANPAY (플래그)** — 이 옵션을 추가하면 **서명자가 자신의 입력만** 묶는다(=다른 입력은 서명에 포함되지 않음).
    
    → 즉, 다른 사람이 **자기 입력을 자유롭게 추가**할 수 있게 해줌.
    

이 둘을 조합해서 (예: `ALL|ANYONECANPAY`, `NONE`, `NONE|ANYONECANPAY`) 다양한 협업/특수한 동작을 만들 수 있습니다.

---

## 1) `ALL | ANYONECANPAY` — 크라우드펀딩(모금) 스타일

### 핵심(한 문장)

- **출력(모금 목표, 즉 “수령자와 지급 액수”)은 모두 고정**되지만, **누구나 자신의 입력(기부금)을 추가**할 수 있다.

### 동작 방식(단계)

1. 모금 주최자가 **목표 금액을 자신에게 지급하는 단일 출력**을 가진 미완성 트랜잭션(아직 입력 없음)을 만든다. (이 상태는 유효하지 않음 — 입력이 없으니까)
2. 기부자는 각자 자신의 **UTXO(자기 돈)를 이 트랜잭션에 입력으로 추가**하고, **`ALL|ANYONECANPAY`*로 서명한다.
    - `ANYONECANPAY` 때문에 기부자는 “내 입력만” 서명한다 → 다른 사람의 입력 추가는 허용
    - `ALL` 때문에 기부자는 “출력(모금자와 목표액)”이 고정되는 것에 동의한다 → 출력 변경 불가
3. 여러 기부자가 입력을 추가해서 총액이 목표에 도달하면 트랜잭션은 유효해지고 모금자가 수령 가능.

### 직관적 의미

- 기부자들은 “나는 이 목표(수령자+금액)에 돈을 보태겠다”는 **약속(서명)**만 하는 셈.
- 충분한 기부(입력)가 모여 목표액을 만족하면 모금자는 그 돈을 실제로 받을 수 있음.

---

## 2) `NONE` — “백지(혹은 일반 수표)” 스타일

### 핵심(한 문장)

- 서명자는 **자신의 입력(및 보통은 다른 입력들도)**에 대해 서명하지만, **출력들은 전혀 묶지 않는다** → 누군가가 출력(누가 받을지, 어느 주소로 보낼지)을 바꿀 수 있다.

### 용도(예: 백지 수표)

- 누군가가 “이 입력(내 돈)을 제공하겠다”는 걸 증명하는 서명을 만들면, 다른 사람이 그 서명을 이용해 **출력을 원하는 대로 채워넣어(누구에게 얼마를 줄지 정해)** 최종 거래를 완성할 수 있음.
- 이걸 **“백지 수표”**로 비유하면: 서명자는 금액(입력에서 나오는 금액)을 제공하겠다고 약속만 하고, 수취인은 나중에 수표 뒷면에 수취인 이름(출력)을 적어 거래를 완성할 수 있음.

### 주의

- 출력이 변경 가능하므로 악용 위험이 있으니, 실제 사용 시 매우 신중해야 합니다.

---

## 3) `NONE | ANYONECANPAY` — “먼지 수집기(dust collector)” 스타일

### 핵심(한 문장)

- **각 기여자는 자신의 작은 UTXO(먼지)를 단독으로 서명해 제출**하고, 이 서명은 출력에 관해 아무 것도 약속하지 않는다. 결과적으로 누군가가 이 많은 작은 입력들을 모아(집합) 큰 거래(수수료를 합리화하는 거래)를 만들 수 있다.

### 왜 이게 유용한가?

- 개인이 가진 아주 작은 UTXO(예: 너무 작은 금액)는 직접 쓰려고 하면 **수수료가 더 비싸서** 사실상 사용 불가(‘먼지’라 불림).
- `NONE|ANYONECANPAY`로 서명하면:
    - 기부자(먼지 보유자)는 자신의 입력만 서명(ANYONECANPAY) → 다른 사람은 추가 입력을 더할 수 있음.
    - 또한 `NONE`이므로 출력을 고정하지 않음 → 모아진 먼지들을 누군가가 모아 하나의 출력(예: 합쳐서 누구에게 보내기)에 쓸 수 있음.
- 즉, 많은 먼지를 **모아(집산) 사용 가능**하게 만드는 패턴입니다.

---

## 보안적·실무적 주의사항 (중요)

- 이런 SIGHASH 트릭은 **강력하지만 위험**합니다. 특히 `NONE`처럼 출력을 묶지 않으면 **누군가가 의도와 다르게 출력(수취인)을 바꿀 수 있음**.
- 따라서 실제 사용에서는 **명확한 프로토콜(규칙)**과 **신뢰 가능한 툴/지갑**을 사용해야 하며, 잘못된 서명 타입 사용은 자금 손실로 이어질 수 있습니다.
- 크라우드펀딩 같은 경우도, 참여자들은 “내 돈이 이 목표에만 쓰인다”는 걸 확실히 이해하고 서명해야 합니다.

---

## 한눈 정리 (표식으로)

| SIGHASH 타입 | 무엇을 묶나(Outputs) | 누구의 입력을 묶나 | 활용 |
| --- | --- | --- | --- |
| `ALL` | 모든 출력 고정 | 서명한 입력 포함(기본) | 일반적인 거래 (안전) |
| `ALL | ANYONECANPAY` | 모든 출력 고정 | **오직 자신의 입력만** |
| `NONE` | 출력 전혀 고정하지 않음 | 보통 모든 입력 서명(=입력 소유권 고정) | “백지 수표” 스타일(출력은 나중에 채움) |
| `NONE | ANYONECANPAY` | 출력 전혀 고정 | 오직 자신의 입력만 |

---

<img width="1785" height="1160" alt="image" src="https://github.com/user-attachments/assets/786bec29-e5cc-44a2-8536-c9792a95dfc3" />

이 표는 **SIGHASH 플래그(Signature Hash Type)** 의 **비트값(value)** 들을 보여주는 표예요.

즉, 여기서 `Value`는 “서명 시 어떤 부분을 해시(hash)에 포함할지를 지정하는 숫자 코드”를 의미합니다.

---

## 🧩 1️⃣ 먼저 큰 그림부터

비트코인에서 트랜잭션을 서명할 때는 단순히 “이 거래 전체를 서명한다”가 아니라

**‘어떤 입력(input)과 어떤 출력(output)을 서명에 포함할지’**를 정해야 합니다.

이걸 제어하는 값이 바로 **SIGHASH 타입**이에요.

트랜잭션의 각 입력(Input)에는 이런 서명 타입이 하나씩 들어갑니다.

---

## ⚙️ 2️⃣ Value는 “비트 플래그(Bit flag)” 값이에요

- 실제로 이 값은 **1바이트(8비트)** 숫자입니다.
- 즉, 여러 기능(플래그)을 **비트 단위로 조합할 수 있습니다.**

👉 그래서 `0x01`, `0x02`, `0x03`, `0x80`, `0x81`처럼 **16진수(0x)** 로 표시된 거예요.

(`0x`는 “16진수임”을 나타내는 표기법이에요.)

---

## 💡 3️⃣ 기본 SIGHASH 타입 값 (0x01 ~ 0x03)

| SIGHASH flag | Value (16진수) = 2진수 형태 | 의미 |
| --- | --- | --- |
| **ALL** | `0x01` = 0000 0001 | 모든 입력·출력을 서명에 포함 (기본값) |
| **NONE** | `0x02` = 0000 0010 | 모든 입력은 포함하지만, **출력은 제외** |
| **SINGLE** | `0x03` = 0000 0011 | 모든 입력은 포함하지만, **자기 인덱스 출력만 포함** |

➡️ 이 세 값은 **출력(Output)을 어떻게 포함할지**를 결정합니다.

---

## 💡 4️⃣ ANYONECANPAY (0x80)

- `0x80` = 1000 0000
- 맨 앞 비트(8번째 비트)가 켜지는 플래그예요.
- 의미:
    
    > “이 서명은 자기 입력 하나만 서명하고, 나머지 입력은 서명에 포함하지 않는다.”
    > 

즉, 다른 사람이 자유롭게 **입력을 추가하거나 제거할 수 있게 열어둠**.

그래서 “크라우드펀딩”, “코인조인(CoinJoin)” 같은 협업 거래에 쓰입니다.

---

## 🧮 5️⃣ 그래서 조합할 수 있습니다 (비트연산)

ANYONECANPAY(`0x80`)는 다른 타입(`0x01~0x03`)과 더해질 수 있어요.

왜냐하면 16진수 `0x80`은 상위 비트(8번째 비트)라서,

아래 세 값과 “비트 OR 연산”으로 조합됩니다.

| 조합 | 계산 | 결과 | 의미 |
| --- | --- | --- | --- |
| `ALL | ANYONECANPAY` | `0x01 + 0x80` | **0x81** |
| `NONE | ANYONECANPAY` | `0x02 + 0x80` | **0x82** |
| `SINGLE | ANYONECANPAY` | `0x03 + 0x80` | **0x83** |

즉,

`0x80`은 **“ANYONECANPAY 플래그를 추가한다”**는 의미입니다.

---

## 📘 6️⃣ 요약 표

| SIGHASH flag | Value (16진수) | 서명에 포함되는 범위 | 설명 |
| --- | --- | --- | --- |
| **ALL** | 0x01 | 모든 입력 + 모든 출력 | 기본값 (가장 안전) |
| **NONE** | 0x02 | 모든 입력 + 출력 없음 | 출력은 나중에 바뀔 수 있음 |
| **SINGLE** | 0x03 | 모든 입력 + 자기 인덱스 출력 | 자기 부분만 확정 |
| **ALL | ANYONECANPAY** | 0x81 | 자기 입력만 + 모든 출력 |
| **NONE | ANYONECANPAY** | 0x82 | 자기 입력만 + 출력 없음 |
| **SINGLE | ANYONECANPAY** | 0x83 | 자기 입력만 + 자기 인덱스 출력 |

---

## 🎯 핵심 정리

> 🔹 Value는 “서명 범위를 정의하는 1바이트 코드”입니다.
> 
> 
> 🔹 `0x01~0x03`은 “출력(Output) 범위”를 정하고,
> 
> 🔹 `0x80`은 “입력(Input) 범위”를 제한하는 ANYONECANPAY 옵션이에요.
> 
> 🔹 두 비트를 조합하면 (예: `0x01 + 0x80 = 0x81`)
> 
> → “내 입력 하나만 + 모든 출력” 같은 복합 조건을 표현할 수 있습니다.
> 

---

원하시면 제가 실제 **비트 단위 그림(비트마스크 구조)** 로

어떤 비트가 어떤 의미(입력/출력/ANYONECANPAY)에 해당하는지 시각화해드릴 수도 있어요 — 해드릴까요?

## Bitcoin Addresses, Balances, and Other Abstractions

- Back to our transaction representation of Bitcoin explorer
- How do you reconstruct the bitcoin addresses?
    1. Retrieve the previous transaction
    2. Retrieve the referenced input
    3. In the locking script → extract the public key hash → encode it using Base58Check

1. Extract each output of the locking script
2. Extract the public key hash
3. Encode it using Base58Check

- Balances of Bob’s bitcoin address?
- Total received? → search through the database of transactions, looking for outputs wit
h P2PKH locking scripts that contain Bob’s public key hash → Summing up the values
- Final Balances? → Monitor the only unspent UTXO with the Bob’s public key hash →
Summing up the values

# 비트코인 주소·잔액·추상화 복원 방법

 핵심은 **블록체인에 저장된 '원시 트랜잭션 데이터'에서 사람-친화적 주소와 잔액을 어떻게 재구성하는지**입니다.

---

## 1) 주소를 어떻게 재구성하나? (탐색기 기준)

비트코인 블록체인에는 `'1GdK...'` 같은 사람이 읽는 주소 문자열 자체가 항상 저장되어 있지는 않습니다. 대신 **출력의 잠금 스크립트(scriptPubKey)** 안에 퍼블릭키 해시 등이 들어 있고, 이를 추출해서 주소로 인코딩(예: Base58Check)하면 사람이 읽을 수 있는 주소가 만들어집니다.

**일반적인 절차 (P2PKH 기준)**

1. **이전 트랜잭션(tx)** 를 가져온다.
2. 그 트랜잭션의 **참조된 출력(vout)** 을 가져온다. (Input이 가리키는 txid + vout)
3. 그 출력의 **locking script(scriptPubKey)** 를 파싱해서 **public key hash (hash160)** 을 추출한다.
4. 그 퍼블릭키 해시를 **Base58Check** 규칙에 따라 인코딩하면 `1...`으로 시작하는 P2PKH 주소가 된다.

또는 반대로 **출력들(vout)** 을 직접 훑어서(블록스캔) 각 출력의 locking script에서 pubKeyHash를 뽑아 주소로 인코딩하는 방식도 동일하게 사용됩니다.

---

## 2) 출력에서 주소 추출(구체적)

- `scriptPubKey` 예: `OP_DUP OP_HASH160 <20-byte pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
    
    → `<20-byte pubKeyHash>` 부분을 꺼내서 Base58Check로 인코딩 → P2PKH 주소.
    
- 다른 스크립트 타입(P2SH, P2WPKH, P2WSH, Taproot 등)은 **추출 방식이 다름**(예: P2SH은 redeem script hash, segwit은 Bech32 인코딩 등).
    
    → 탐색기는 각 스크립트 타입을 먼저 판별한 뒤 적절히 추출·인코딩합니다.
    

---

## 3) 주소의 총수령(total received)과 최종잔액(final balance)의 차이

### (A) Total received (지금까지 그 주소로 들어온 총액)

- 방법: 데이터베이스(또는 블록 스캔)를 통해 **해당 주소와 매칭되는 모든 출력(outputs)** 을 찾고(보통 P2PKH의 pubKeyHash가 일치하는 outputs), 그 `value`들을 모두 합산(sum).
- 의미: 그 주소가 과거에 '얼마를 받았는가'의 누적치 — 이미 사용(spent)해서 다른 곳으로 보낸 금액 포함되지 않음.

### (B) Final balance (현재 잔액)

- 방법: **UTXO 집합(미사용 출력들)** 중에서 **해당 주소에 속한(unspent) UTXO들만 골라** `value`들을 합산.
- 의미: 실제로 지금 그 주소(지갑)가 사용할 수 있는 금액. `Total received − total spent` 와 동일한 결과(동일한 계산을 다른 방식으로 한 것).

간단히:

- `Total received` = 모든 수신 output의 합(과거 누적).
- `Final balance` = **미사용(UTXO)** output들의 합(현재 사용 가능한 잔액).

---

### Q. 왜 추상화인가?

**“주소(address)”나 “잔액(balance)” 같은 개념은 실제로 블록체인에 *존재하지 않는다*는 사실**이에요.

그래서 강의자료의 소제목이 **“Abstractions(추상화)”** 인 거예요.

---

## 🧱 1️⃣ 비트코인 블록체인의 실제 데이터에는 “주소”나 “잔액”이 없음

비트코인의 실제 데이터 구조를 보면, 블록체인에는 이런 식으로만 기록되어 있어요:

- 트랜잭션 (Transaction)
    - 입력(Inputs)
    - 출력(Outputs)
        - `value`: 금액(사토시 단위)
        - `scriptPubKey`: “이 출력을 누가 쓸 수 있는가”를 나타내는 **조건 스크립트**

여기에는 우리가 익숙한 **“주소(address)”나 “계좌(account)”** 같은 필드는 없습니다.

---

## 💡 2️⃣ 그런데 우리는 익숙하게 “주소”와 “잔액”으로 봄

비트코인 탐색기나 지갑 앱에서는 이렇게 보이죠:

```
주소: 1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA
잔액: 0.85 BTC

```

이건 편의상 그렇게 **“표현”한 것뿐이에요.**

사실 내부적으로는 다음 과정을 거칩니다:

1. 모든 트랜잭션의 **출력(scriptPubKey)** 에서 퍼블릭키 해시(`pubKeyHash`)를 추출
2. 그걸 Base58Check로 인코딩해서 **사람이 읽기 좋은 주소 문자열**로 변환
3. 그 주소(pubKeyHash)에 속한 UTXO들을 합쳐 **잔액(balance)** 을 계산

즉, **주소와 잔액은 블록체인 위의 복잡한 데이터 구조를 사람이 이해하기 쉽게 단순화(추상화)한 개념**이에요.

---

## 🔍 3️⃣ “Abstraction(추상화)”란?

컴퓨터 과학에서 **추상화(abstraction)** 는 이렇게 정의할 수 있습니다:

> “복잡한 내부 동작을 숨기고, 사용자에게는 단순한 개념적 모델만 보여주는 것.”
> 

비트코인에서 이 개념이 딱 들어맞아요.

| 실제 데이터 (복잡한 구조) | 사람이 보는 추상 개념 |
| --- | --- |
| 트랜잭션의 Input / Output / scriptPubKey | 송신자와 수신자 |
| UTXO 집합 | 잔액(balance) |
| 퍼블릭키 해시(pubKeyHash) | 주소(address) |

---

## 🧠 4️⃣ 강의자료 제목의 의미 요약

> “Bitcoin Addresses, Balances, and Other Abstractions”
> 
> 
> = “비트코인의 주소, 잔액, 그리고 그 밖의 추상적 개념들”
> 

즉,

> “주소나 잔액 같은 건 실제 블록체인 데이터에 존재하지 않는다.
> 
> 
> 그건 우리가 데이터를 이해하기 쉽게 만든 ‘추상화된 표현’이다.”
> 

---

## 🎯 예시로 완벽히 이해하기

### 실제 블록체인에는

```
"vout": [
  {
    "value": 0.015,
    "scriptPubKey": "OP_DUP OP_HASH160 ab6802... OP_EQUALVERIFY OP_CHECKSIG"
  }
]

```

### 우리가 보는 건

```
받는 주소: 1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA
받은 금액: 0.015 BTC

```

> 👉 위 ‘주소’는 실제로 존재하지 않고,
> 
> 
> `ab6802...` 라는 퍼블릭키 해시를 사람이 보기 좋게 바꾼 **추상화된 이름(label)** 이에요.
> 

---

## 🔖 결론

| 개념 | 블록체인에 실제로 존재? | 역할 | 비유 |
| --- | --- | --- | --- |
| **주소(Address)** | ❌ | 퍼블릭키 해시를 사람이 읽기 좋게 바꾼 것 | 이메일 주소 (사람이 보기 쉬운 이름) |
| **잔액(Balance)** | ❌ | 해당 주소의 미사용 출력(UTXO) 합계 | 은행 계좌의 잔액처럼 보이지만 실제로는 여러 동전의 합 |
| **추상화(Abstraction)** | ✅ | 위처럼 복잡한 내부 구조를 단순한 개념으로 표현한 것 | “현금 동전 묶음을 ‘내 지갑 잔액’으로 보는 것” |

---

📘 **요약 한 문장으로**

> “주소(address)”와 “잔액(balance)”은 블록체인에 실제로 저장된 데이터가 아니라,
복잡한 트랜잭션·UTXO 구조를 사람이 이해하기 쉽게 만든 ‘추상화된 개념(abstractions)’이다.
>

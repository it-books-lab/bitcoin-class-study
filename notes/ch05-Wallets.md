# 1. PPT(~p.18)

소개  지갑은 주요 사용자 인터페이스 역할을 하는 애플리케이션입니다.  지갑은 사용자의 자금 접근을 제어하며, 키와 주소를 관리하고, 잔액을 추적하며, 거래를 생성하고 서명합니다.  지갑은 사용자의 키를 저장하고 관리하는 데 사용되는 데이터 구조를 의미합니다.  비트코인 지갑은 비트코인을 포함하지 않고, 키만 포함합니다. 따라서 지갑은 키 체인입니다.

---

비결정론적 지갑 - 1  이 유형의 지갑은 JBOK(Just a Bunch(다발) Of Keys)로도 알려져 있습니다.  무작위로 생성된 개인 키.  무작위 키의 단점은 많은 키를 생성할 경우 모든 키의 사본을 보관해야 한다는 점으로, 지갑을 자주 백업해야 한다는 의미입니다.  이는 각 비트코인 주소를 단일 거래에만 사용하여 주소 재사용을 피한다는 원칙과 직접적으로 충돌합니다.

→ 지갑을 자주 백업해야 하니까 주소 재사용을 피하는 것을 위해 비용이 많이 든다는 말!

→ 키를 만들 때마다 백업 필요. 주소들마다 키가 필요하다보니 항상 백업을 해야 함.

결정론적 지갑(Deterministic Wallet) - 1  결정론적 지갑 또는 '시드 기반(seed-based)' 지갑은 모두 공통 시드(seed)에서 파생된 개인 키를 포함하는 지갑입니다. 이는 단방향 해시 함수(one-way hash function)를 사용하여 이루어집니다.  시드는 무작위로 생성된 숫자로, 인덱스 번호(index number)나 '체인 코드(chain code)'와 같은 다른 데이터와 결합되어 개인 키를 파생합니다.  시드만으로 모든 파생 키를 복구할 수 있으므로, 생성 시점의 단일 백업만으로 충분합니다.

→ 시드에 해당하는 키만 백업해두고, 나머지 주소들은 그 한 키를 통해 계산해낼 수 있음.

---

HD 지갑 - 1  HD 지갑은 '계층적 결정론적(Hierarchical Deterministic)'을 의미합니다.  결정론적 지갑 중 가장 발전된 형태는 BIP-32 표준에 의해 정의된 HD 지갑입니다.  HD 지갑은 트리 구조로 파생된 키를 포함하며, 부모 키가 일련의 자식 키를 파생할 수 있습니다.

HD 지갑 - 3  HD 지갑은 무작위 키에 비해 두 가지 주요 장점을 제공합니다.– 1. 트리 구조를 사용하여 추가적인 조직적 의미를 표현할 수 있습니다.– 2. HD 지갑의 장점은 사용자가 해당 개인 키에 접근하지 않고도 공개 키 시퀀스를 생성할 수 있다는 것입니다.

## Q. 그럼 최하위층 전까지는 다 private key이고, 최하위층 키는 전부 public key야?

질문하신 **부모키, 자식키, 손자키**가 꼭 "개인키=부모, 공개키=자식"을 의미하는 건 아닙니다. HD 지갑(BIP-32)의 키 파생 구조는 **개인키/공개키 모두 계층적으로 존재**해요.

---

### 🔑 HD 지갑에서의 키 계층 구조

BIP-32에서 키는 두 가지로 파생됩니다:

1. **Extended Private Key (xprv)**
    - `개인키 + 체인코드`를 포함
    - 여기서 다시 **자식 개인키**를 무한히 파생할 수 있음
    - 자식 개인키 → 자식 공개키 계산 가능 (일반적인 ECC 방식)
2. **Extended Public Key (xpub)**
    - `공개키 + 체인코드`를 포함
    - 여기서 **자식 공개키**만 파생할 수 있음
    - 즉, 개인키 없이도 주소를 무한히 만들어낼 수 있음

---

### 📌 부모-자식 관계 예시

- 부모 개인키(xprv) → 자식 개인키(xprv_child)
- 부모 공개키(xpub) → 자식 공개키(xpub_child)

즉, **부모키, 자식키, 손자키**는 모두

- 개인키 트리(xprv 트리) 안에서도 있고,
- 공개키 트리(xpub 트리) 안에서도 있어요.

---

### 🚫 오해 풀기

- **"부모키 = private, 자식키 = public"** → ❌ (잘못된 이해)
- 올바른 이해 → **"부모/자식/손자"는 단순히 계층적 관계를 나타내는 표현**이고, 각 단계마다 **개인키 버전(xprv)과 공개키 버전(xpub)**이 따로 존재합니다.

---

### 💡 쉽게 비유

- 마스터 **개인키** = "만능 열쇠" (모든 자식 열쇠를 만들 수 있음)
- 마스터 **공개키** = "만능 복사본 설계도" (주소/자식 공개키는 만들 수 있지만, 열쇠 자체는 못 만듦)
- 부모/자식/손자 = 건물의 층 구조처럼, **위에서 아래로 파생되는 레벨**을 뜻할 뿐이지 private/public을 구분하는 개념이 아님.

---

시드와 니모닉 코드(BIP-39)  HD 지갑은 일련의 영어 단어로부터 시드를 생성하는 표준화된 방법과 결합됩니다.  이는 니모닉으로 알려져 있으며, 표준은 BIP-39에 의해 정의됩니다.

니모닉 코드 단어 (BIP-39) - 1  니모닉 코드 단어는 결정적 지갑을 파생시키기 위해 시드로 사용되는 임의의 숫자를 나타내는(인코딩하는) 단어 시퀀스입니다.  니모닉 단어 생성 방법– 1. 128~256비트의 임의 시퀀스(엔트로피)를 생성합니다.– 2. SHA256 해시의 첫 (엔트로피 길이/32) 비트를 취하여 임의 시퀀스의 체크섬을 생성합니다.– 3. 체크섬을 임의 시퀀스의 끝에 추가합니다.– 4. 시퀀스를 11비트 단위로 나눕니다.– 5. 각 11비트 값을 2048단어의 사전에 정의된 단어 중 하나에 매핑합니다.– 6. 니모닉 코드는 단어들의 시퀀스입니다.

니모닉 코드 단어(BIP-39) - 3  엔트로피는 키 스트레칭 함수 PBKDF2(암호 기반 키 도출 함수-Password-Based Key Derivation Function)를 사용하여 더 긴(512비트) 시드를 도출하는 데 사용됩니다.  니모닉을 이용하여 시드를 생성하는 방법 – 7. PBKDF2 키 스트레칭 함수의 첫 번째 매개변수는 6단계에서 생성된 니모닉입니다. – 8. PBKDF2 키 스트레칭 함수의 두 번째 매개변수는 솔트입니다. 솔트는 문자열 상수 "mnemonic"과 사용자가 제공한 선택적 비밀번호 문자열을 결합하여 구성됩니다. – 9. PBKDF2는 HMAC-SHA512 알고리즘을 사용하여 2048회 해싱을 통해 니모닉과 솔트 매개변수를 확장하며, 최종 출력으로 512비트 값을 생성합니다. 이 512비트 값이 바로 시드입니다.

니모닉 코드 단어(BIP-39) - 5 

 128비트 엔트로피 암기 코드, passphrase 없음

 128비트 엔트로피 암기 코드, passphrase 포함

---

BIP-39의 선택적 암호 구문 - 1  BIP-39 표준은 시드 파생 시 optional passphrase의 사용을 허용합니다.  실제로 하나의 니모닉이 주어지면, 가능한 모든 암호 구문은 서로 다른 시드로 이어집니다.  선택적 암호 구문은 두 가지 중요한 기능을 생성합니다: – 두 번째 인증 요소(기억하는 것)로, 니모닉 백업이 도난 당해도 단독으로는 니모닉을 사용할 수 없게 하여 보호합니다. – 실행 가능한 부인형 또는 "강제 지갑" 형태로, 선택한 암호 구문이 소량의 자금을 가진 지갑으로 연결되어 공격자를 실제 자금이 대부분 있는 "진짜" 지갑에서 분산시키는 역할을 합니다.

BIP-39의 선택적 비밀번호 - 2  비밀번호 사용 위험:– 지갑 소유자가 무능력하거나 사망하고 아무도 비밀번호를 모르면 시드는 무용지물이 되며 지갑에 저장된 모든 자금은 영원히 사라집니다.– 반대로, 소유자가 비밀번호를 시드와 같은 곳에 백업하면 두 번째 인증 요소의 목적이 무력화됩니다.

---

# 2. GPT 요약 버전

## 1) 지갑(Wallet)이란?

- 지갑 = 사용자의 **키(비밀키/공개키)를 저장·관리**하고, 잔액을 추적하며 거래를 생성하고 서명하는 앱 또는 데이터 구조입니다.
- **비트코인 ‘지갑’은 코인 자체를 담고 있지 않고, 키(키 체인)만 보관**합니다.

## 2) 비결정론적 지갑 (JBOK) → 키 생성 비결정(무작위 생성)

- JBOK = **Just a Bunch Of Keys** — 키들을 무작위로 많이 생성해 저장함.
- 장점: 구현이 간단.
- 단점: 키 별로 모두 백업해야 해서 번거롭고, 주소를 많이 만들면 백업 누락 위험↑. (따라서 잦은 백업 필요)
- 주소 재사용을 피하려는 관행과 충돌할 수 있음.

# 3) 결정론적 지갑 (Seed-based) →

- 하나의 **시드(seed)** 에서 여러 개인키를 **파생(derivation)** 하는 방식.
- 핵심: **시드만 백업하면** 그 시드로부터 모든 키(주소)를 다시 만들 수 있음 → 백업이 훨씬 쉬워짐.
- 파생은 **단방향 해시 함수**를 사용.

# 4) HD 지갑 (Hierarchical Deterministic, BIP-32)

- 결정론적 지갑의 발전형. 키들이 **트리 구조**로 조직됨.
- 부모키에서 여러 자식키를 파생할 수 있어 **조직적 관리**가 쉬움(예: 계정, 용도별 분리).
- 추가 장점: **공개키(또는 공개키 시퀀스)를 가진 상태에서 개인키 노출 없이** 주소를 생성할 수 있음(조회/수신용으로 유용).

---

## Q. 그럼, 그냥 결정론적 지갑이랑 비결정론적 지갑은 개인키를 노출해서 주소를 생성해?

## 1. 기본 구조 복습

- 주소(Address)는 사실 **공개키(Public Key)** 를 해시한 결과예요.
- 즉:
    
    개인키(Private Key) → 공개키(Public Key) → 주소(Address)
    

👉 그러므로 **주소를 만들려면 “공개키”만 있으면 됩니다.**

개인키 자체는 필요 없어요.

---

## 2. 비결정론적 / 결정론적 지갑에서의 현실

- JBOK(비결정론적) 지갑이나 초기 결정론적 지갑은,
    
    "주소를 만들고 싶다" = **새 개인키 생성 → 그로부터 공개키 계산 → 주소 계산**
    
- 즉, 새로운 주소를 만들려면 **항상 개인키를 지갑이 생성/보관**해야 했습니다.
- 그래서 "주소 생성 = 개인키도 같이 관리"가 사실상 필수였어요.

---

## 3. HD 지갑(BIP-32)의 차별점

- HD 지갑은 특별히 **확장 공개키(Extended Public Key, xPub)** 라는 개념을 도입합니다.
- xPub을 알고 있으면:
    - 개인키 없이도 여러 공개키 → 주소를 쭉쭉 파생 가능 ✅
- 단, 서명(=코인 사용)은 여전히 개인키 필요.

👉 그래서 HD 지갑에서는 **지갑을 ‘읽기 전용(Watch-only wallet)’으로 만들 수 있습니다.**

- 예: 회계팀은 입금 주소들을 무한히 생성해서 고객에게 줄 수 있지만,
    
    돈을 빼가는 건 절대 못함(개인키가 없으니까).
    
- 개발자/서버가 해킹당해도 개인키 유출 없이 주소만 관리 가능.

---

## 4. 정리

- ❌ 비결정론적/결정론적 지갑 = 주소를 새로 만들 때마다 개인키도 같이 필요함.
- ✅ HD 지갑 = **공개키만으로도 새로운 주소 생성 가능** (xPub 덕분).
    
    → 즉, "주소 생성"과 "개인키 관리"를 분리할 수 있음.
    

---


# 5) 니모닉(Seed 문구) — BIP-39

- 시드를 사람이 외우기 쉬운 **영단어들(니모닉)** 로 표현하는 표준이 BIP-39.
- **만드는 방법(간단 요약)**
    1. 128~256비트의 엔트로피(무작위 비트) 생성
    2. SHA-256 해시에서 체크섬 일부를 붙임
    3. 그 비트를 11비트 단위로 나눠, 각 11비트를 **2048단어 사전**의 단어 하나로 매핑
    4. 결과가 니모닉(예: 12/15/18/21/24단어)
- 니모닉 → 실제 시드(512비트)는 **PBKDF2(HMAC-SHA512, 2048회)** 로 도출됩니다.
    - 이 과정에서 니모닉(문구) + 솔트("mnemonic"+선택적 비밀번호)를 사용.


---

## Q. ‘니모닉 → 실제 시드(512비트)는 **PBKDF2(HMAC-SHA512, 2048회)** 로 도출됩니다. 이 과정에서 니모닉(문구) + 솔트("mnemonic"+선택적 비밀번호)를 사용.’이 무슨 말인가요?

## “니모닉 → 시드(PBKDF2, HMAC-SHA512, 2048회)”란?

- 니모닉(예: 12개의 영어 단어)은 그냥 **사람이 외우기 좋은 형태**일 뿐이에요.
- 이걸 바로 키로 쓰지 않고, **PBKDF2**라는 함수에 넣어 **시드(seed, 512비트)**를 만듭니다.

📌 과정:

- 입력: 니모닉(단어열) + 솔트( `"mnemonic" + 선택적 비밀번호` )
- 알고리즘: HMAC-SHA512를 2048번 반복 → 키 스트레칭(key stretching)
- 출력: 512비트 시드

➡️ 이 **시드**가 다시 HD 지갑(BIP-32)의 마스터 개인키·공개키를 파생하는 뿌리가 됩니다.

즉, **니모닉은 시드를 만드는 재료**이고, **시드는 실제 키의 근원**이에요.

---



# 6) 선택적 비밀번호(passphrase) — BIP-39 옵션

- 니모닉 외에 **추가 비밀번호(선택)** 를 넣을 수 있음.
- 효과: 같은 니모닉이라도 비밀번호가 다르면 **완전히 다른 시드**가 생성됨.
- 장점:
    - **2차 인증 요소** 역할 — 니모닉이 도난되더라도 비밀번호 없이는 복구 불가.
    - **강제 지갑**(plausible deniability): 공격자에게 보여줄 “겉지갑”을 만들 수 있음(진짜 자금과 분리).
- 위험:
    - 비밀번호를 잊으면 복구 불능(자금 영구 손실).
    - 비밀번호를 니모닉과 함께 백업하면 2차 인증의 의미가 사라짐.

---

## Q. ‘**강제 지갑**(plausible deniability): 공격자에게 보여줄 “겉지갑”을 만들 수 있음(진짜 자금과 분리).’이 갑자기 무슨 말인가요? 공격자에게 뭘 보여주나요?

## “강제 지갑(plausible deniability)”이란?

- 공격자가 총을 들고 와서 “니모닉 말해라!” 라고 협박한다고 가정해 볼게요 😅
- 니모닉만으로는 시드가 확정되지 않아요. 왜냐면 **추가 비밀번호(passphrase)**가 있어야 최종 시드가 결정되거든요.
- 따라서 **같은 니모닉**이라도:
    - passphrase = `""` (없음) → “겉지갑”(작은 금액 들어있는 지갑)
    - passphrase = `"MySecret123!"` → “진짜 지갑”(실제 큰 자금 들어있는 지갑)

👉 이렇게 **겉지갑/진짜지갑** 두 개를 만들어 둘 수 있고, 공격자에게는 겉지갑용 니모닉만 알려주면서 “전 재산은 여기 있습니다”라고 속일 수 있습니다. 이게 바로 **plausible deniability (그럴듯한 부인 가능성)** 기능이에요.

---

## Q. ‘비밀번호를 니모닉과 함께 백업하면 2차 인증의 의미가 사라짐.’이면 니모닉과 비밀번호는 따로 백업하라는 말인가요?

## “니모닉과 비밀번호는 따로 백업해야 한다”는 뜻

- 만약 종이에 이렇게 적어두면:
    
    ```
    니모닉: apple banana ... zoo
    비밀번호: MySecret123!
    
    ```
    
    → 해커가 이 종이를 훔치면 그냥 평문 니모닉과 비밀번호를 모두 갖게 되니까, **2차 인증 효과가 사라짐**.
    

📌 올바른 백업 방법:

- **니모닉**은 종이에 적어서 오프라인 보관 (금고, 은행 안전금고 등)
- *비밀번호(passphrase)**는 **다른 장소**에 보관 (머릿속에만 기억하거나, 다른 안전한 위치에 적어둠)

이렇게 분리해야 니모닉이 유출되어도 비밀번호가 없으면 자금을 복구할 수 없습니다.

---

# 7) 실무 팁(정리)

- HD 지갑 + 니모닉 사용 권장 — **한 번만 안전하게 백업하면** 됨.
- 니모닉은 절대 온라인에 저장하지 말고, 가능한 오프라인으로(종이에 쓰거나 금속에 새기기).
- 비밀번호(passphrase)는 강력하지만 **잊지 않도록 주의**. 대체 복구 수단도 고려.
- 주소 재사용 금지 — 프라이버시와 보안에 유리.
- 니모닉(12단어 vs 24단어): 숫자 길이(엔트로피)가 크면 보안성↑(예: 12단어 ≈ 128비트 엔트로피, 24단어 ≈ 256비트 엔트로피).

# 8) 자주 묻는 질문(짧게)

- Q: 지갑을 잃어버리면? → 니모닉(시드)만 있으면 다른 지갑 앱에서 복구 가능.
- Q: 지갑에 코인이 들어있나? → 아니다 — 코인은 블록체인에 있고, 지갑은 키(접근 권한)를 가진 것뿐.
- Q: 니모닉과 비밀번호 둘 다 잃으면? → 복구 불가(자금 손실).

---

# 3. GPT 부연설명

## 1. 개인키(Private Key)

- **비트코인 소유권을 증명하는 “비밀 숫자”**
- 랜덤하게 만들어지는 매우 큰 수(256비트).
- 개인키를 아는 사람만 그 주소의 비트코인을 쓸 수 있어요.
- → 지갑의 가장 중요한 정보 = 개인키.

👉 예시: `5Kb8k...` 이런 형태 (실제로는 16진수/58진수 인코딩됨).

---

## 2. 공개키(Public Key)

- 개인키에서 수학적 함수(타원곡선 연산, ECDSA)로 계산됨.
- 누구나 개인키 → 공개키는 쉽게 계산할 수 있지만,
    
    공개키 → 개인키는 사실상 불가능(수학적으로 어려움).
    
- 거래에서 서명을 검증하는 데 사용.

👉 즉, 공개키는 "개인키로 만든 전자서명을 확인하는 용도".

---

## 3. 주소(Address)

- 공개키를 다시 **압축+해시(Hash)** 해서 만든 "짧은 표현".
- 사람이 쓰기 편하도록 Base58로 바꿔 `1A1zP1...` 같은 형태.
- 비트코인을 보낼 때 입력하는 “계좌번호” 같은 것.

👉 구조:

개인키 → 공개키 → 주소

(→ 이 주소를 다른 사람이 알아도 개인키 없으면 비트코인을 못 씀).

---

## 4. 부모키(Parent Key)와 자식키(Child Key) — (HD 지갑에서만 등장)

- HD 지갑(BIP-32)에서는 키들이 **트리 구조**로 파생돼요.

### 부모키 (Parent Key)

- 하나의 “시드(seed)”로부터 처음 생성된 키 → 다른 키들을 만들어내는 기준.
- 부모 개인키 + 체인코드 → 여러 자식 개인키 생성 가능.

### 자식키 (Child Key)

- 부모키에서 파생된 키.
- 자식키도 또 부모가 될 수 있음 → 그 밑에서 손자키 생성 가능.

👉 즉, HD 지갑에서는 **부모-자식 관계**로 수많은 키를 계층적으로 관리 가능.

예:

- 계정1: 결제용 주소들
- 계정2: 저축용 주소들
- 계정3: 회사 경비용 주소들

---

## 📌 전체 그림 (흐름 정리)

1. **시드(seed)** → (해시 함수) → 첫 번째 **개인키**
2. 개인키 → (수학적 변환) → **공개키**
3. 공개키 → (해시 함수) → **주소**

→ HD 지갑에서는 이 과정을 트리 구조로 확장:

- 부모 개인키에서 여러 자식 개인키 파생 → 각각 공개키/주소 생성 가능.

---

## ✅ 요약표

| 용어 | 의미 | 비유 |
| --- | --- | --- |
| 개인키 | 비밀 숫자, 소유권 증명 | 금고 열쇠 |
| 공개키 | 개인키로 계산된 공개 값, 서명 검증용 | 금고 열쇠 구멍 모양 |
| 주소 | 공개키를 압축/해시한 것, 돈을 받을 때 쓰는 ID | 금고의 “번호표” |
| 부모키 | HD 지갑에서 다른 키를 만들어내는 상위 키 | 나무의 줄기 |
| 자식키 | 부모키에서 파생된 키 | 나무의 가지/잎 |

---

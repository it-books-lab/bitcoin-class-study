
# (p.2) Intro

이 강의자료는 **비트코인 스크립트(script)**를 좀 더 고급 수준으로 다루는 내용이에요. 즉, 단순히 “A가 B에게 코인을 보낸다”가 아니라, **‘특정 조건을 만족해야만’ 송금이 가능한 트랜잭션(거래)**을 만드는 방법을 설명하는 장입니다.

하나씩 자세히 풀어볼게요.

---

## 🧩 Chapter 7. Advanced Transactions and Scripting (고급 트랜잭션과 스크립팅)

### 💡 개요 (Introduction)

이 장에서는 **더 복잡한 조건을 가진 비트코인 트랜잭션을 만드는 스크립트**를 다룹니다.

### 주요 학습 내용:

1. **Multi-signature (다중서명)**
    
    여러 사람의 서명을 모두 받아야만 거래가 승인되는 구조입니다.
    
2. **Pay-to-Script-Hash (P2SH)**
    
    복잡한 스크립트를 직접 노출하지 않고, 그 스크립트의 **해시값만 블록체인에 저장**하는 방식입니다.
    
3. **Timelock (시간 제한 트랜잭션)**
    
    일정 시간이 지나야만 거래가 유효해지는 기능입니다.
    

---

# (p.3~11) Multi-Signature

## 🔐 Multi-Signature (다중서명) — Introduction

### 1️⃣ 개념

다중서명 스크립트는 **여러 개의 공개키(Public Key)** 를 지정하고,

그 중 **일정 개수 이상의 개인키(Private Key)로 서명(Signature)** 해야만

자금을 사용할 수 있도록 설정하는 트랜잭션입니다.

👉 즉, “여러 명 중 일부가 동의해야 돈이 움직인다”는 구조예요.

이를 **M-of-N (M 중 N 서명)** 스키마라고 부릅니다.

- **N:** 전체 참여자 수 (공개키의 수)
- **M:** 실제로 서명이 필요한 최소 인원 수

---

### 2️⃣ 예시: 2-of-3 Multi-Signature

**상황 가정:**

회사 공동 지갑을 세 명이 관리합니다.

- Alice
- Bob
- Carol

하지만 보안을 위해,

> “셋 중 최소 두 명이 서명해야만 돈을 인출할 수 있다”
> 
> 
> 는 규칙을 만들고 싶습니다.
> 

➡️ 이럴 때 사용하는 스크립트가 **2-of-3 Multi-Sig** 입니다.

---

### 3️⃣ 동작 과정 예시

| 단계 | 설명 |
| --- | --- |
| **1. 지갑 생성** | Alice, Bob, Carol의 **공개키 3개**를 모아 하나의 **multi-sig 주소**를 만듭니다. |
| **2. 자금 입금** | 회사 자금을 이 multi-sig 주소로 송금합니다. (아직 아무도 돈을 못 씀) |
| **3. 송금 요청 발생** | 예를 들어 Carol이 거래를 생성하여, “회사 지갑에서 외부로 송금하자”고 제안 |
| **4. 서명 수집** | Alice와 Bob이 각각 본인 **개인키로 서명** |
| **5. 조건 충족 확인** | 3명 중 2명이 서명했으므로, **2-of-3 조건 만족 ✅** |
| **6. 거래 전송** | 비트코인 네트워크에 전송 → 검증 후 승인됩니다. |

---

이번에는 **multi-signature의 Locking Script (자금 잠금 스크립트)** 와 **Validation (검증 과정)** 을 구체적으로 설명할게요. 이 부분은 비트코인 트랜잭션이 “어떻게 잠기고 풀리는지”를 실제 스크립트 관점에서 보여주는 핵심입니다.

---

## 🔐 Multi-signature – Locking Script (잠금 스크립트)

### 1️⃣ 개념 정리

비트코인 트랜잭션에서 **Locking Script**(또는 **scriptPubKey**)는 “돈을 언제, 누구에게 줄 수 있는가?”를 정의하는 **조건문(script)**입니다.

> 즉, “이 돈을 쓰려면 어떤 조건을 만족해야 하는가?”를 지정하는 스크립트예요.
> 

Multi-signature의 경우, 그 조건은 다음과 같습니다 👇

> “총 N개의 공개키 중 **M개의 서명(Signature)**이 있어야 한다.”
> 

---

### 2️⃣ 일반적인 형식 (General Form)

```
M <Public Key 1> <Public Key 2> ... <Public Key N> N CHECKMULTISIG

```

### 구성요소 설명:

| 구성요소 | 의미 |
| --- | --- |
| **M** | 필요한 최소 서명 개수 (Threshold) |
| **<Public Key 1> …** | 참가자들의 공개키 |
| **N** | 총 공개키의 수 |
| **CHECKMULTISIG** | 여러 서명을 검증하는 스크립트 명령어 |

---

### 4️⃣ Unlocking Script (해제 스크립트)

Locking Script는 “조건”을 정의했으니, Unlocking Script는 **그 조건을 실제로 만족시키는 증거**를 제공합니다.

Unlocking Script는 **scriptSig** 라고도 부릅니다.

예를 들어, **Bob과 Carol**이 서명했다면 Unlocking Script는 이렇게 됩니다:

```
<Signature_B> <Signature_C>

```

> 즉, “이 돈을 풀 수 있는 두 개의 유효한 서명”을 제공한 것입니다.
> 

---

### 5️⃣ Combined Script (결합된 검증 스크립트)

비트코인 노드가 트랜잭션을 검증할 때는 **Unlocking Script + Locking Script를 이어붙여서 실행**합니다.

결합된 스크립트는 다음과 같이 됩니다 👇

```
<Signature_B> <Signature_C>
2 <PubKey_A> <PubKey_B> <PubKey_C> 3 CHECKMULTISIG

```

이 전체 스크립트를 스택 기반으로 해석하면:

| 단계 | 동작 |
| --- | --- |
| 1 | 서명 B와 C가 스택에 push 됨 |
| 2 | 2 (필요 서명 수) push |
| 3 | 공개키 3개 push |
| 4 | 3 (총 공개키 수) push |
| 5 | `CHECKMULTISIG` 실행 — 두 서명이 세 공개키 중 두 개에 매칭되는지 검사 |
| ✅ | 조건이 맞으면 TRUE 반환 (트랜잭션 유효) |

---

## 🧮 Multi-signature – Validation (검증 과정)

### 1️⃣ 검증의 핵심

비트코인 네트워크는 다음을 확인합니다:

> Unlocking Script의 서명들이 Locking Script에 명시된 공개키 조건을 만족하는가?
> 

즉,

- Locking Script는 “2-of-3 구조”로 자금을 **잠가둠**
- Unlocking Script는 “서명 2개”로 이를 **풀어줌**

---

### 2️⃣ 검증 절차

| 단계 | 설명 |
| --- | --- |
| **①** | 트랜잭션의 Unlocking Script를 가져와 실행 (서명 push) |
| **②** | Locking Script 실행 (공개키, 조건 push 후 CHECKMULTISIG 실행) |
| **③** | 각 서명이 올바른 공개키에 대응하는지 확인 |
| **④** | 필요한 개수(M)의 서명이 모두 유효하면 스크립트 전체가 TRUE 평가됨 |
| **⑤** | TRUE → 트랜잭션 유효, 블록체인에 포함 가능 |

---

### ✅ 요약

| 구분 | 설명 |
| --- | --- |
| **Locking Script (scriptPubKey)** | M-of-N 조건 정의 (`2 <PubKeyA> <PubKeyB> <PubKeyC> 3 CHECKMULTISIG`) |
| **Unlocking Script (scriptSig)** | 실제 서명 데이터 제공 (`<SigB> <SigC>`) |
| **결합 스크립트** | 두 스크립트를 이어붙여 검증 (`<SigB> <SigC> 2 PubA PubB PubC 3 CHECKMULTISIG`) |
| **검증 결과** | 조건 만족 시 TRUE → 자금 사용 가능 |

---

이번 내용은 비트코인 스크립트의 역사적인 **버그(checkmultisig 버그)**에 관한 이야기예요.

이 버그는 비트코인 초창기 코드에 존재했지만, **이미 너무 많은 트랜잭션이 이 버그를 포함한 상태로 존재하기 때문에 수정하지 않고 그대로 표준으로 남겨둔** 사례입니다.

하나씩 차근차근 이해해볼게요.

---

## 🧩 Multi-signature – A Bug in `CHECKMULTISIG`

(다중서명 검증 연산자에 존재하는 버그)

---

### 1️⃣ 기본 개념 복습

앞서 배운 `CHECKMULTISIG` 명령어는 다음 역할을 합니다:

> “스택(Stack)에 있는 여러 공개키와 여러 서명을 비교해, M-of-N 조건을 만족하는가를 검증한다.”
> 

즉, 실행 시 스택에서 다음 항목들을 꺼내 사용해야 합니다:

| 항목 | 의미 |
| --- | --- |
| **N** | 총 공개키 수 |
| **Public Key 1 ~ N** | 서명 검증에 사용할 공개키들 |
| **M** | 필요한 최소 서명 수 |
| **Signature 1 ~ M** | 실제 제공된 서명들 |

따라서, 원래 설계상으로는 `CHECKMULTISIG`가 **M + N + 2 개의 아이템을 스택에서 pop**해야 정상이에요.

---

### 2️⃣ 버그의 원인

하지만... 구현에 **버그**가 있었습니다 😅

> CHECKMULTISIG는 실제로 하나를 더(pop) 해버립니다.
> 

즉, **M+N+2개가 아니라 M+N+3개**를 꺼내버리는 거예요.

---

### 3️⃣ 실제 동작 과정 (예시로 설명)

이전 예시를 다시 써볼게요.

우리는 2-of-3 Multi-sig 스크립트를 사용하고 있었습니다.

### ✅ Locking Script (잠금 스크립트)

```
2 <PubKey_A> <PubKey_B> <PubKey_C> 3 CHECKMULTISIG

```

### ✅ Unlocking Script (정상이라면 이렇게 되어야 함)

```
<Signature_B> <Signature_C>

```

그런데 이걸 실제로 결합해서 실행하면 어떻게 될까요?

```
<Signature_B> <Signature_C>
2 <PubKey_A> <PubKey_B> <PubKey_C> 3 CHECKMULTISIG

```

---

### 4️⃣ 버그가 발생하는 부분

`CHECKMULTISIG`가 실행될 때의 과정:

| 단계 | 동작 | 스택 상태 |
| --- | --- | --- |
| ① | `N` (3) pop → 공개키 개수 획득 |  |
| ② | 공개키 3개 pop (A, B, C) |  |
| ③ | `M` (2) pop → 필요한 서명 개수 획득 |  |
| ④ | 서명 2개 pop (Signature_B, Signature_C) |  |
| ❌ **⑤ (버그)** | 예상치 못하게 **한 개 더 pop** 해버림! |  |

즉, 마지막에 **불필요하게 한 항목을 더 꺼내 버린다**는 게 문제예요.

---

### 5️⃣ 그럼 어떤 일이 생길까?

그 “추가로 pop된 항목”은 **무시(disregard)** 되기 때문에

검증에는 직접적인 영향을 주지 않습니다.

하지만…

> 만약 스택에 그 “추가 항목”이 없으면,
> 
> 
> `CHECKMULTISIG`이 빈 스택에서 pop을 시도해서 **에러(stack underflow)** 가 납니다.
> 
> → 트랜잭션은 **실패(Invalid)** 됩니다 ❌
> 

그래서 스크립트를 성공시키기 위해 **빈 자리 하나를 채워줘야** 해요.

---

### 6️⃣ 해결 방법: Dummy Value (보통 0)

이 문제를 피하기 위해, Unlocking Script에서 **맨 앞에 0을 추가**합니다.

즉, 실제로 사용되는 Unlocking Script는 다음과 같습니다:

### ❌ 잘못된 (이론적) 형태

```
<Signature_B> <Signature_C>

```

### ✅ 실제 사용하는 형태 (버그 회피용)

```
0 <Signature_B> <Signature_C>

```

---

### 7️⃣ 전체 검증 스크립트의 실제 모습

버그를 반영한 실제 결합된 검증 스크립트는 이렇게 됩니다 👇

```
0 <Signature_B> <Signature_C>
2 <PubKey_A> <PubKey_B> <PubKey_C> 3 CHECKMULTISIG

```

---

### 8️⃣ 실행 순서로 보면

| 단계 | 동작 | 스택에서 꺼낸 항목 | 비고 |
| --- | --- | --- | --- |
| ① | 0 pop | Dummy 값 | 버그 보정용 |
| ② | 3 pop | N = 3 | 공개키 개수 |
| ③ | A, B, C pop | 공개키 3개 |  |
| ④ | 2 pop | M = 2 | 필요한 서명 수 |
| ⑤ | Sig_B, Sig_C pop | 서명 2개 | 검증 수행 |
| ✅ | 검증 통과 → TRUE 반환 |  | 성공! |

---

### 9️⃣ 정리: CHECKMULTISIG 버그 요약표

| 구분 | 설명 |
| --- | --- |
| **버그 내용** | CHECKMULTISIG가 스택에서 1개를 더 pop함 |
| **문제점** | Dummy 값이 없으면 “Stack underflow error” 발생 |
| **해결 방법** | Unlocking Script의 맨 앞에 0을 추가 |
| **영향** | 실제 서명 검증에는 영향 없음 |
| **표준 Unlocking Script 형태** | `0 <Signature1> <Signature2> ...` |

---

### ✅ 핵심 요약

| 항목 | 설명 |
| --- | --- |
| 정상적으로는 | `CHECKMULTISIG`는 M+N+2개 항목 사용 |
| 실제 동작은 | M+N+3개 pop (1개 더 꺼냄) |
| 보정 방법 | Unlocking Script 맨 앞에 `0` 추가 |
| 실제 사용 예 | `0 <Sig1> <Sig2> 2 PubA PubB PubC 3 CHECKMULTISIG` |
| 영향 | 검증에는 영향 없음, 단지 스택 안정성 확보용 |

---

이 버그는 지금도 여전히 **비트코인 프로토콜의 “공식 사양”으로 남아 있습니다.**

즉, 나중에라도 고치면 과거 모든 멀티시그 트랜잭션이 깨지기 때문에

‘버그이지만 표준’으로 취급되는 특이한 사례예요.

---

# (p.12~18) P2SH

이번엔 **P2SH(Pay-to-Script-Hash)**의 도입 배경과 왜 유용한지, 특히 멀티시그와 연결해서 “왜 필요했는가”를 쉬운 예시로 풀어볼게요.

---

# P2SH (Pay-to-Script-Hash) – 소개

## 1) P2SH는 뭐고, 왜 쓰나요?

**P2SH**는 “복잡한 스크립트(조건)”를 **짧은 해시 하나**로 바꿔서 쓰게 해 주는 방식이에요.

- 원래 비트코인은 돈을 잠그는 조건(락 스크립트, scriptPubKey)을 **그대로** 출력에 담습니다.
- 그런데 멀티시그처럼 조건이 길어지면, **거래가 커지고(feerate × 바이트 수), 수수료도 커지고, 모든 노드의 메모리(UTXO 세트) 부담도 커져요.**
- **P2SH**는 “긴 스크립트 전체” 대신 **그 스크립트의 해시값(짧은 바이트열)** 만 출력에 넣게 해 줍니다.
    
    → 보내는 사람(고객)은 짧은 주소(= 스크립트 해시)에만 보내면 되고, **복잡함과 무게는 받는 쪽**이 나중에 돈을 **쓸 때** 부담합니다.
    

> 한 줄 요약: P2SH = “복잡한 스크립트 ⇒ 해시로 축약해서 보낸다.”
> 
> 
> 보내는 사람은 간단, 받는 사람(소유자)은 사용할 때 스크립트 원문과 서명을 제시.
> 

---

## 2) 모하메드 회사 사례로 이해하기

### 상황

- 모하메드의 회사는 **법인 지갑**을 모두 **멀티시그**로 운영합니다.
- “받아야 할 돈(AR, Accounts Receivable)”—즉 **고객 결제**도 전부 **멀티시그**로 받도록 설계했어요.
- 예: **2-of-3** 구조 — 모하메드 + 파트너들 중 1명 **또는** 변호사(백업 키) 포함해 최소 2명이 서명해야 인출 가능.

### 문제점 (Bare Multisig: 멀티시그 스크립트를 그대로 쓰는 경우)

1. **스크립트가 길다**
    - 멀티시그 락 스크립트는 이렇게 생깁니다(개념적으로):
        
        ```
        2 <PubKey_A> <PubKey_B> <PubKey_C> 3 CHECKMULTISIG
        
        ```
        
    - `<PubKey_*>`가 전부 **긴 공개키**이고, 토큰화된 스크립트도 길어서 **출력(scriptPubKey)이 비대**해져요.
2. **트랜잭션 크기가 커진다 → 수수료가 커진다**
    - 비트코인 수수료는 보통 **거래 크기(vB) × 단가(sat/vB)** 로 계산합니다.
    - 동일 금액이라도 **스크립트가 길수록 vB가 커지므로, 수수료가 더 많이 듭니다.**
    - 문제는 이 수수료를 **돈을 보내는 고객**이 부담한다는 점이에요.
        - 고객 입장에선 “왜 내가 회사 내부 보안 구조(멀티시그)의 무게까지 대신 내야 하나?”가 됩니다.
3. **UTXO 세트 RAM 부담**
    - **모든 풀노드**는 “아직 쓰이지 않은 출력(UTXO)”을 **RAM**에 들고 있어야 해요.
    - 멀티시그 락 스크립트를 **그대로** 쓰면, 각 UTXO의 scriptPubKey가 **비정상적으로 커져서** 전 세계 노드의 메모리를 더 잡아먹습니다.
    - 이 출력이 **사용(소비)** 되기 전까지는 계속 RAM에 남습니다.
    - 즉, **네트워크 전체에 불필요한 메모리 비용을 전가**하게 되죠.

---

## 3) P2SH가 해결하는 점

**핵심 아이디어:**

“긴 멀티시그 스크립트”를 **그 해시값(짧은 값)** 으로 바꿔 **출력에 기록**합니다.

- 고객이 보내는 출력(scriptPubKey)은 **짧고 표준화된 형태**여서 **수수료·UTXO RAM 부담이 크게 줄어듭니다.**
- 모하메드 회사는 **P2SH 주소(= 스크립트 해시 기반 주소)** 를 고객에게 알려주면 됩니다.
- 나중에 돈을 **쓸 때**(회사가 자금을 인출할 때), 모하메드 측이:
    - **원래의 멀티시그 스크립트(“리딤 스크립트”)** 와
    - **요구되는 서명들(예: 2개)**
        
        를 Unlocking Script로 제출해 **해시가 일치하는지 + 서명 검증**을 거칩니다.
        
        → 복잡함은 **수취인(모하메드 회사)** 이 **사용 시점**에만 부담!
        

### 간단 비교

| 항목 | Bare Multisig(그대로) | **P2SH** |
| --- | --- | --- |
| 고객이 보는 주소/출력 | 길고 복잡한 스크립트 | **짧은 해시 기반 주소** |
| 고객 수수료 부담 | **큼** (출력이 길어 vB↑) | **작음** (출력이 짧아 vB↓) |
| UTXO RAM 부담(전 세계 노드) | **큼** (긴 scriptPubKey) | **작음** (짧은 scriptPubKey) |
| 복잡성 부담 시점 | 받는 순간부터 | **쓸 때만** (수취인이 리딤 스크립트 제시) |

---

## 4) 예시로 정리 (2-of-3 멀티시그)

### (A) Bare 멀티시그로 받는 경우

- **Locking script**(출력):
    
    ```
    2 <PubA> <PubB> <PubC> 3 CHECKMULTISIG
    
    ```
    
- 고객이 보내는 거래는 **출력 스크립트가 길어져** 수수료↑
- 이 UTXO가 소비될 때까지 **모든 노드 RAM**에 이 긴 스크립트가 남음

### (B) P2SH로 받는 경우

- 회사가 내부에서 멀티시그 리딤 스크립트를 정하고 **그 해시**를 주소로 만듦(예: `3...`으로 시작하는 P2SH 주소 형태)
- **Locking script**(출력)는 짧은 표준 P2SH 형식(“해시에 지불”)
- 고객은 **일반 주소에 보내듯** 짧은 P2SH 주소로 전송 → **수수료 적음**
- 나중에 회사가 돈을 **쓸 때**, 다음을 제시:
    - `0 <SigX> <SigY> ...` (멀티시그 버그 때문에 더미 0 포함)
    - `<RedeemScript = "2 <PubA> <PubB> <PubC> 3 CHECKMULTISIG">`
- 노드는 리딤 스크립트의 해시가 P2SH 출력의 해시와 **일치하는지** 확인하고, 이어서 **CHECKMULTISIG**로 서명 2개가 유효한지 검증

---

## 5) **P2SH 후(after)에 비해 P2SH 전(before)는** 거래 크기가 약 5배

- 결과적으로 **보내는 사람의 수수료 부담**을 **크게** 줄여 줍니다. (네트워크 RAM도 절약)

---

## 6) 핵심 요약

- **문제**: 멀티시그를 그대로 쓰면 스크립트가 길어 **거래 수수료↑, UTXO RAM↑, 고객이 부담**
- **해결**: **P2SH**는 **긴 스크립트를 해시로 축약**해 출력에 넣게 하여,
    - 보내는 쪽(고객)의 거래를 **짧고 싸게**,
    - 네트워크 전체 RAM 부담을 **작게**,
    - 복잡한 검증은 **수취인이 돈을 사용할 때** 수행하도록 **책임을 이동**시킴

---

이 이미지들은 **P2SH(Pay-to-Script-Hash)** 의 핵심 개념과 실제 동작 과정을 시각적으로 보여주는 강의자료입니다.
아래에서는 각 슬라이드 내용을 **쉬운 한국어로 단계별로** 풀어드릴게요.

## 🧩 1️⃣ Table 7-1 vs Table 7-2 — P2SH 등장 전과 후 비교

### 📘 (1) P2SH가 없던 시절

- **Locking Script (잠금 스크립트)**
    
    ```
    2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG
    
    ```
    
    → 5개의 공개키 중 2개의 서명이 있어야 돈을 쓸 수 있다는 조건.
    
- **Unlocking Script (잠금 해제 스크립트)**
    
    ```
    Sig1 Sig2
    
    ```
    
    → 실제로 두 개의 서명을 제공하면 조건이 충족돼서 사용 가능.
    

❗️문제: 공개키 5개, 서명 2개 등으로 스크립트가 길고 거래 크기가 커짐 → 수수료와 메모리 부담이 커짐.

---

### 📗 (2) P2SH가 도입된 이후

- **Redeem Script (리딤 스크립트)**
    
    ```
    2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG
    
    ```
    
    → 원래의 “복잡한 스크립트”를 내부적으로 보관.
    
- **Locking Script (잠금 스크립트)**
    
    ```
    HASH160 <20-byte hash of redeem script> EQUAL
    
    ```
    
    → 복잡한 스크립트를 **직접 넣지 않고**,
    
    그 **스크립트의 해시값(짧은 형태)**만 잠금 조건으로 저장.
    
- **Unlocking Script (잠금 해제 스크립트)**
    
    ```
    Sig1 Sig2 <redeem script>
    
    ```
    
    → 돈을 쓸 때, 실제 리딤 스크립트와 서명을 함께 제출해 검증.
    

🧠 요약:

> “길고 복잡한 스크립트 대신 해시값으로 잠그고, 사용할 때 원래 스크립트를 제시해서 해시가 일치하는지 확인하는 구조.”
> 

---

## 🏢 2️⃣ Mohammed 회사 예시 — P2SH가 왜 필요한가?

### 상황:

모하메드 회사는 **5명**이 관리하는 **법인 멀티시그 지갑**을 사용.

```
2 <Mohammed’s PubKey> <Partner1> <Partner2> <Partner3> <Attorney> 5 CHECKMULTISIG

```

→ 즉, **5개의 공개키 중 2개의 서명**이 있어야 자금을 인출할 수 있음.

### 문제:

- 이런 스크립트는 길고(공개키 5개가 모두 포함)
- 트랜잭션이 커짐 → 수수료 5배 가까이 늘어남
- 모든 풀노드의 UTXO 세트에 커다란 데이터가 남음

---

## 🔢 3️⃣ 복잡한 스크립트를 해시로 줄이기

이 스크립트를 짧게 표현하기 위해 **해시(Hash)** 를 사용합니다.

- P2SH는 리딤 스크립트 전체를 해시로 요약해 저장합니다.
- 해시 생성 과정:
    1. `SHA256`으로 한 번 해시
    2. 결과를 다시 `RIPEMD160`으로 해시
        
        → 이중 해싱 결과는 20바이트의 짧은 해시값이 됩니다.
        

예시 결과:

```
HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL

```

이제 이 **20바이트 해시**가 “돈이 잠긴 주소”가 됩니다.

- 고객은 이 해시 기반 P2SH 주소로 송금.
- 긴 멀티시그 스크립트를 직접 포함하지 않아도 됨.

---

## 🔐 4️⃣ P2SH의 실제 구조 — 스택 동작 이해하기

P2SH 트랜잭션의 핵심은 **두 개의 스크립트**가 함께 작동한다는 점이에요.

### 🧩 잠금 스크립트 (Locking Script / scriptPubKey)

```
HASH160 <20-byte hash of redeem script> EQUAL

```

### 🧩 잠금 해제 스크립트 (Unlocking Script / scriptSig)

```
0 Signature1 Signature2 <redeem script>

```

> 💡 맨 앞의 0은 CHECKMULTISIG 버그 보정용 더미값입니다. (앞서 배웠죠!)
> 

---

### 🧠 실행 흐름

1. **Unlocking Script가 스택에 push됨**
    
    ```
    0
    Signature1
    Signature2
    <redeem script>
    
    ```
    
2. **Locking Script 실행**
    - Redeem Script를 해시(SHA256 → RIPEMD160)
    - 그 결과와 scriptPubKey의 해시가 같은지 비교
    - 같으면 TRUE → Redeem Script 실행 단계로 넘어감
3. **Redeem Script 실행**
    - Redeem Script의 내용은 `2 PubKey1~5 5 CHECKMULTISIG`
    - Signature1, Signature2가 두 개의 공개키와 일치하는지 검증
    - 조건 충족 시 전체 스크립트 TRUE → 자금 사용 가능

---

### ⚙️ 그림 설명 (마지막 이미지)

오른쪽 그림은 스택 상태를 시각화한 것입니다.

- **왼쪽 초반 스택**
    
    Unlocking Script + Locking Script가 순서대로 push됨
    
    (0, Sig1, Sig2, RedeemScript, HASH160, HashValue, EQUAL)
    
- **HASH 검증 후**
    
    Redeem Script의 해시가 일치 → Redeem Script 실행으로 교체됨
    
- **Redeem Script 실행**
    
    2개의 서명이 5개의 공개키 중 유효한 2개에 매칭되면 TRUE 반환 → 성공.
    

---

## ✅ 정리 요약표

| 구분 | 스크립트 내용 | 설명 |
| --- | --- | --- |
| **Redeem Script** | `2 PubKey1 ... PubKey5 5 CHECKMULTISIG` | 실제 잠금 조건 (원본 스크립트) |
| **Locking Script (scriptPubKey)** | `HASH160 <hash(redeem script)> EQUAL` | 해시값으로 잠금 — 짧고 효율적 |
| **Unlocking Script (scriptSig)** | `0 Sig1 Sig2 <redeem script>` | 서명 2개 + 원본 스크립트 제시 |
| **검증 과정** | ① 해시 일치 확인 → ② Redeem Script 실행 → ③ CHECKMULTISIG로 서명 검증 | 조건 만족 시 TRUE (트랜잭션 유효) |

---

## 🔍 결론

| P2SH 도입 전 | P2SH 도입 후 |
| --- | --- |
| 긴 멀티시그 스크립트가 그대로 들어감 | 해시값으로 축약됨 |
| 트랜잭션 크기 큼 → 수수료↑ | 트랜잭션 크기 작음 → 수수료↓ |
| 모든 노드의 RAM 부담↑ | 네트워크 자원 절약 |
| 고객이 복잡한 구조 부담 | 수취인이 해제할 때만 복잡한 검증 수행 |

---

# (p.19~22) P2SH Address

이 부분은 **P2SH 주소(Pay-to-Script-Hash Address)** 의 생성 과정과 그 **장점(benefits)**, **한계(loss)** 를 설명하는 내용이에요.

하나씩 차근차근 풀어서 쉽게 정리해드릴게요.

---

## 🧩 1️⃣ P2SH 주소 (Pay-to-Script-Hash Address) — 개념 정리

### 💡 P2SH 주소란?

P2SH는 “**복잡한 스크립트(script)**”의 **해시값**으로 만든 주소입니다.

즉,

> 비트코인 주소가 “공개키의 해시”라면,
> 
> 
> P2SH 주소는 “**스크립트(script)의 해시**”예요.
> 

그래서 **복잡한 멀티시그 스크립트 전체를 짧은 주소 하나로 표현**할 수 있습니다.

---

## 🧠 2️⃣ P2SH 주소는 어떻게 만들어질까?

### (1) Redeem Script → 해시값으로 변환

먼저, 다음과 같은 **복잡한 멀티시그 스크립트**가 있다고 합시다:

```
2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 CHECKMULTISIG

```

이 전체 스크립트를 **해시(HASH160)** 함수로 압축합니다.

- `HASH160` = `RIPEMD160(SHA256(script))`
    
    → 즉, SHA256 한 번 → 그 결과를 다시 RIPEMD160 해시로.
    

결과:

```
HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e EQUAL

```

이 `54c557e07dde5bb6cb...` 부분이 바로 **리딤 스크립트의 20바이트 해시값**이에요.

---

### (2) 해시값 → Base58Check 인코딩

이제 이 20바이트 해시값을 사람이 읽을 수 있는 주소로 변환해야 합니다.

비트코인 주소는 **Base58Check** 방식으로 인코딩됩니다.

(숫자 0, O, I, l 같은 헷갈리는 문자를 제외한 58개의 문자로 표현)

- P2PKH 주소(일반 비트코인 주소)는 prefix `0x00` (→ 주소가 “1”로 시작)
- **P2SH 주소는 prefix `0x05`** (→ 주소가 “3”으로 시작)

그래서 최종적으로 다음과 같은 주소가 만들어집니다:

```
3 9RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw

```

👉 “3”으로 시작하는 주소는 **P2SH 주소**입니다.

---

### 📘 정리

| 항목 | 설명 |
| --- | --- |
| 입력 | 복잡한 스크립트 (ex. 멀티시그 Redeem Script) |
| 변환 과정 | SHA256 → RIPEMD160 → HASH160(20바이트) → Base58Check 인코딩 |
| Prefix | 0x05 → 주소 첫 글자가 “3” |
| 결과 | `3xxxxxx` 형태의 짧은 P2SH 주소 생성 |

---

## 💼 3️⃣ 예시: Mohammed 회사 사례

모하메드 회사의 5인 멀티시그 리딤 스크립트:

```
2
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395...
...D238F4D800
5 CHECKMULTISIG

```

이 긴 스크립트 전체를 **HASH160**으로 압축하면:

```
54c557e07dde5bb6cb791c7a540e0a4796f5e97e

```

이걸 Base58Check로 바꾸면:

```
39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw

```

따라서 이 주소(`3`으로 시작)는

→ **모하메드 회사의 멀티시그 지갑을 대표하는 단 하나의 P2SH 주소**가 됩니다.

이제 고객은 이 긴 스크립트를 몰라도,

그냥 `3...` 주소로 송금만 하면 돼요 ✅

---

## 🚀 4️⃣ P2SH의 장점 (Benefits)

| 번호 | 설명 | 요약 |
| --- | --- | --- |
| **①** | 복잡한 스크립트를 짧은 “지문(fingerprint)” 형태로 바꾸므로 트랜잭션 크기가 작아짐 | 💰 수수료 절약 |
| **②** | 스크립트를 **주소 형태**로 표현할 수 있으므로, 송금자(고객)는 복잡한 내부 구조를 몰라도 됨 | 💡 사용자 편의성 향상 |
| **③** | 스크립트를 만드는 부담이 **보내는 사람(sender)** 이 아닌 **받는 사람(recipient)** 에게 전가됨 | 🎯 단순 송금 가능 |
| **④** | 긴 스크립트는 UTXO 세트(=모든 노드의 RAM)에 저장되지 않고, 나중에 쓸 때 입력으로 포함됨 | 🧠 네트워크 메모리 절약 |
| **⑤** | 즉, “현재(송금 시)”의 부담이 “미래(사용 시)”로 이동함 | ⏳ 효율적 자원 분배 |
| **⑥** | 긴 스크립트로 인해 발생하는 수수료 부담도 **송금자 → 수취인**으로 이동 | ⚖️ 수수료 부담 전가 |

요약하자면 👇

> “보내는 사람은 간단하게,
> 
> 
> 받는 사람은 사용할 때 복잡한 스크립트를 제시하는 구조로 바뀐다.”
> 

---

## ⚠️ 5️⃣ P2SH의 단점 (Loss / 주의점)

| 항목 | 내용 |
| --- | --- |
| **①** | 리딤 스크립트는 “해시” 형태로만 네트워크에 존재하므로, 실제 스크립트 원문은 나중에 사용할 때까지 아무도 모름 |
| **②** | 만약 리딤 스크립트를 잘못 만들어서 해시값이 엉뚱하면? → 송금은 성공하지만, **나중에 절대 사용할 수 없음 (돈이 영구적으로 잠김)** |
| **③** | 왜냐하면 네트워크는 해시값이 유효한지 아닌지를 알 수 없기 때문 — 해시 자체는 아무 의미가 없는 무작위 바이트열처럼 보이니까요 |
| **④** | 즉, **해시만 맞고 스크립트 자체가 유효하지 않더라도** 일단 거래는 블록체인에 기록됨. 하지만 이후 사용할 때 실패함. |

💬 쉽게 말하면,

> “P2SH는 송금할 땐 안전하고 편하지만,
> 
> 
> 리딤 스크립트를 잘못 만들어서 그 해시로 잠그면,
> 
> 절대로 풀 수 없는 금고를 만든 셈이에요.”
> 

---

## 🧩 6️⃣ 전체 요약

| 구분 | 내용 |
| --- | --- |
| **P2SH 주소 생성** | 복잡한 스크립트를 해시(HASH160) 후 Base58Check 인코딩 (주소는 ‘3’으로 시작) |
| **예시** | 해시: `54c557e07dde5b...` → 주소: `39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw` |
| **장점** | 송금자 부담↓, 트랜잭션 크기↓, 네트워크 효율↑ |
| **단점** | 리딤 스크립트가 잘못되면 복구 불가 (돈이 영구적으로 잠김) |
| **핵심 아이디어** | “보내는 사람은 단순하게, 받는 사람은 복잡함을 나중에 처리” |

---
